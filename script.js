function typewriterWrite(element, fullHTML, options = {}, onDone = null) {
    const speedMin = options.speedMin || 13;
    const speedMax = options.speedMax || 46;
    const paragraphPause = options.paragraphPause || 240;
    
    // Vyma≈æeme v≈°echny star√© kurzory a glitch-taily, a≈• je klid na neonov√©m h≈ôbitovƒõ ü™¶
    element.querySelectorAll('.typewriter-cursor, .glitch-tail').forEach(c => c.remove());
    element.innerHTML = '<span class="typewriter-cursor">|<span class="glitch-tail"></span></span>';
    let i = 0;
    let openTags = [];

    // Paleta barev pro glitchuj√≠c√≠ ocas ‚Äì a≈• to sv√≠t√≠ jako rozbit√Ω CRT monitor! üåà
    const glitchColors = ['#00fff9', '#ff00c8', '#faff00', '#fff', '#ff0040', '#00cc00', '#ff6600'];
    
    // Funkce pro generov√°n√≠ n√°hodn√Ωch glitch znak≈Ø
    function getGlitchTail() {
        const glitchSet = ['N', 'Y', 'H', 'S', 'M', 'T', '#', '¬§', '%', '&', '@', '¬ß', '√∑', '√ó', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '‚óè', '‚óä', '|', '/', '\\', '_', '-', '^', '~', '.', '*', '+'];
        const count = 5 + Math.floor(Math.random() * 5); // 5‚Äì10 znak≈Ø
        let result = '';
        for (let j = 0; j < count; j++) {
            result += glitchSet[Math.floor(Math.random() * glitchSet.length)];
        }
        return result;
    }

    function updateCursor() {
        // V≈°echny star√© kurzory a glitch-taily do ≈°rotu, ≈æ√°dn√© digit√°ln√≠ zombie! üî™
        element.querySelectorAll('.typewriter-cursor, .glitch-tail').forEach(c => c.remove());
        const cursor = document.createElement('span');
        cursor.className = 'typewriter-cursor';
        cursor.innerHTML = '|<span class="glitch-tail">' + getGlitchTail() + '</span>';
        element.appendChild(cursor);

        // Glitchuj√≠c√≠ ocas, co hled√° znaky i barvy jako ≈°√≠len√Ω AI na Red Bullu üòµ
        const glitchTail = cursor.querySelector('.glitch-tail');
        const glitchInterval = setInterval(() => {
            if (!glitchTail || !glitchTail.parentNode) {
                clearInterval(glitchInterval); // Zastav, pokud kurzor zmiz√≠
                console.log('üõë Glitch tail interval zru≈°en ‚Äì kurzor je mrtv√Ω!');
                return;
            }
            glitchTail.textContent = getGlitchTail();
            const newColor = glitchColors[Math.floor(Math.random() * glitchColors.length)];
            glitchTail.style.color = newColor;
            glitchTail.style.textShadow = `0 0 8px ${newColor}, 0 0 16px ${newColor}, 0 0 24px ${newColor}`;
            console.log(`üé® Glitch tail barva: ${newColor}, font-size: ${getComputedStyle(glitchTail).fontSize}`); // Debug styl≈Ø
        }, 100); // Obnova ka≈æd√Ωch 100ms pro po≈ô√°dn√Ω chaos
    }

    function writeNext() {
        // V≈°echny star√© kurzory a glitch-taily pryƒç, a≈• to nen√≠ bordel jako k√≥d z 90. let üßπ
        element.querySelectorAll('.typewriter-cursor, .glitch-tail').forEach(c => c.remove());

        if (i < fullHTML.length) {
            if (fullHTML[i] === "<") {
                let end = fullHTML.indexOf(">", i);
                let tag = fullHTML.slice(i, end + 1);
                element.innerHTML += tag;
                // Spr√°va tag≈Ø, proto≈æe HTML je jako minov√© pole ‚Äì ≈°patn√Ω krok a bum! üí•
                if (!tag.startsWith("</")) {
                    let tagName = tag.match(/^<([a-zA-Z0-9]+)/);
                    if (tagName) openTags.push(tagName[1]);
                } else {
                    openTags.pop();
                }
                i = end + 1;
                updateCursor();
                // Pauza po <br>, proto≈æe i k√≥d pot≈ôebuje odpoƒç√≠vat ‚òï
                if (tag.toLowerCase().startsWith('<br')) {
                    setTimeout(writeNext, paragraphPause + Math.random()*170);
                    return;
                }
                setTimeout(writeNext, speedMin);
                return;
            }
            // Vypisuj p√≠smena s gr√°ci√≠, ne jako tisk√°rna na speedu üñ®Ô∏è
            if (openTags.length) {
                let targetTag = element.querySelectorAll(openTags[openTags.length-1]);
                if (targetTag.length) {
                    targetTag[targetTag.length-1].innerHTML += fullHTML[i++];
                } else {
                    element.innerHTML += fullHTML[i++];
                }
            } else {
                element.innerHTML += fullHTML[i++];
            }
            updateCursor();
            // Debug: Zalogujeme font-size aktu√°ln√≠ho elementu
            console.log(`‚úçÔ∏è P√≠≈°eme: font-size: ${getComputedStyle(element).fontSize}`);
            setTimeout(writeNext, speedMin + Math.random() * (speedMax-speedMin));
        } else {
            // Konec psan√≠, aplikujeme .typing-done a zkontrolujeme styly
            element.classList.add('typing-done');
            element.querySelectorAll('.typewriter-cursor, .glitch-tail').forEach(c => c.remove());
            if (onDone) onDone();
            console.log(`‚úÖ Typewriter dokonƒçil, font-size po dokonƒçen√≠: ${getComputedStyle(element).fontSize}`);
        }
    }
    writeNext();
}

function typewriterParagraphs(element, text, options = {}, onDone = null) {
    const paragraphs = text
        .replace(/\r\n/g, '\n')    // Sjedno≈• ≈ô√°dky, a≈• to nen√≠ digit√°ln√≠ apokalypsa üî•
        .split(/\n\s*\n/)          // Rozdƒõl na odstavce, ≈æ√°dn√© halucinace
        .filter(p => p.trim() !== '');

    let idx = 0;
    function writeNextParagraph() {
        if (idx < paragraphs.length) {
            // Nov√Ω odstavec, ƒçist√Ω jako du≈°e novƒõ vytvo≈ôen√©ho divu üôè
            const p = document.createElement('p');
            element.appendChild(p);
            typewriterWrite(p, paragraphs[idx], options, () => {
                idx++;
                setTimeout(writeNextParagraph, 250); // Pauza, a≈• ƒçten√°≈ô nekolabuje üò¥
            });
        } else if (onDone) {
            onDone();
        }
    }
    writeNextParagraph();
}

// Zbytek k√≥du z≈Øst√°v√°, proto≈æe navigace je zp√°tky v neonov√© sl√°vƒõ üí•
document.addEventListener('DOMContentLoaded', () => {
    console.log('üéÆ SYNTHOMA script initialized. System status: GLITCH_STABILIZED_RGB');

    // Inicializace glitch efektu pro .glitch elementy
    document.querySelectorAll('.glitch').forEach(el => {
        const originalText = el.textContent;
        el.textContent = ''; // Vyƒçisti p≈Øvodn√≠ text

        // Rozbij text na spany
        [...originalText].forEach(char => {
            const span = document.createElement('span');
            span.textContent = char;
            span.classList.add('glitch-char');
            el.appendChild(span);
        });

        const spans = el.querySelectorAll('.glitch-char');
        setInterval(() => {
            spans.forEach((span, idx) => {
                if (span.textContent.trim() && Math.random() < 0.08) {
                    // Mal√Ω glitch na jednotliv√© p√≠smeno
                    span.textContent = getGlitchChar(span.dataset.original || span.textContent);
                    span.classList.add('glitchy');
                    setTimeout(() => {
                        span.textContent = span.dataset.original || originalText[idx];
                        span.classList.remove('glitchy');
                    }, 10 + Math.random() * 60);
                }
            });
        }, 60);

        // Ulo≈æ origin√°l do datasetu (pro spr√°vn√© vracen√≠)
        spans.forEach((span, i) => {
            span.dataset.original = originalText[i];
        });

        // Nƒõkdy extra efekt na cel√Ω element
        setInterval(() => {
            if (Math.random() > 0.985) {
                el.classList.add('glitch-quick');
                setTimeout(() => el.classList.remove('glitch-quick'), 120 + Math.random() * 140);
            }
        }, 1850);
    });

    // Inicializace canvasu pro pozad√≠
    const canvas = document.getElementById('glitch-bg');
    let ctx, W, H;

    if (canvas) {
        ctx = canvas.getContext('2d');
        
        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W;
            canvas.height = H;
        }
        
        window.addEventListener('resize', resize);
        resize();

        const colors = ['#00fff9', '#ff00c8', '#faff00', '#fff'];
        const MAX_LINES = 11;
        let lastDraw = 0;

        function draw(now) {
            if (!ctx) return;
            
            if (now - lastDraw < 60) {
                requestAnimationFrame(draw);
                return;
            }
            lastDraw = now;

            ctx.clearRect(0, 0, W, H);

            // Jemn√Ω tmav√Ω ≈°um
            ctx.globalAlpha = 0.14;
            for(let i = 0; i < 6; i++) {
                ctx.fillStyle = '#101015';
                ctx.fillRect(0, Math.random()*H, W, Math.random()*7+1);
            }
            ctx.globalAlpha = 1.0;

            for(let i = 0; i < MAX_LINES; i++) {
                if(Math.random() > 0.35) continue;

                let y = Math.random() * H;
                let h = Math.random() * 4 + 1;
                let x = Math.random() * W * 0.85;
                let w = Math.random() * W * 0.22 + 40;
                let color = colors[Math.floor(Math.random()*colors.length)];
                
                ctx.save();
                ctx.globalCompositeOperation = (Math.random() > 0.7) ? "lighter" : "screen";
                ctx.shadowBlur = 10 + Math.random()*12;
                ctx.shadowColor = color;
                ctx.globalAlpha = 0.13 + Math.random()*0.22;
                ctx.fillStyle = color;

                if(Math.random() > 0.77) {
                    ctx.transform(1, Math.random()*0.07-0.03, Math.random()*0.08-0.04, 1, 0, 0);
                }
                ctx.fillRect(x, y, w, h);
                ctx.restore();
            }

            // Velk√Ω glitch pruh
            if(Math.random() > 0.992) {
                ctx.save();
                let y = Math.random() * H;
                ctx.globalAlpha = 0.3;
                ctx.shadowBlur = 23;
                ctx.shadowColor = colors[Math.floor(Math.random()*colors.length)];
                ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];
                ctx.fillRect(0, y, W, Math.random()*7+3);
                ctx.restore();
            }

            requestAnimationFrame(draw);
        }

        requestAnimationFrame(draw);
    }

    // Inicializace typewritter efektu
    const fullText = `<h5 class= "glitch">LOG [WELCOME]:</h5>‚ÄûVstupuje≈° do SYNTHOMY. Nelekej se, pokud ti p≈ôi ƒçten√≠ zaƒçne lehce ≈°kubat lev√© oko ‚Äì je to bƒõ≈æn√Ω vedlej≈°√≠ efekt.‚Äú
<h5 class= "glitch">LOG [WHAT_IS_THIS]:</h5>‚ÄûSYNTHOMA je kniha i svƒõt. Glitch-noir p≈ô√≠bƒõh z temn√© digit√°ln√≠ budoucnosti, kde se ka≈æd√Ω tv≈Øj strach a ka≈æd√© trauma mƒõn√≠ v datov√Ω log. Pamƒõ≈• je tu ≈°elma. AI tƒõ provede ‚Äì se sarkasmem m√≠sto empatie. V≈°echno, co c√≠t√≠≈°, se z√°lohuje. Tady je bezpeƒç√≠ jen iluze. Restart je rutina, chyba je souƒç√°st cesty.‚Äú
<h5 class= "glitch">LOG [FOR_READERS]:</h5>‚ÄûTato kniha nen√≠ manu√°l ke ≈°tƒõst√≠. Je to pr≈Øvodce mƒõstem rozbit√Ωch emoc√≠, kde hlavn√≠ hrdina NULL je sbƒõratel ciz√≠ch chyb ‚Äì a jeho par≈•√°k je ironick√° AI. Humor je ƒçern√Ω, atmosf√©ra temn√°, a vƒõt≈°ina vtip≈Ø bol√≠ je≈°tƒõ minutu po p≈ôeƒçten√≠.‚Äú
<h5 class= "glitch">LOG [WARNING]:</h5>‚ÄûVarov√°n√≠: SYNTHOMA analyzuje i va≈°e selh√°n√≠. Pokud se v√°m nƒõco bude zd√°t povƒõdom√©, je to t√≠m, ≈æe v tom nejste sami. ƒåten√≠ m≈Ø≈æe zp≈Øsobit m√≠rnou existenci√°ln√≠ krizi, sm√≠ch p≈ôes slzy a nutk√°n√≠ restartovat vlastn√≠ ≈æivot.‚Äú
<h5 class= "glitch">LOG [SUMMARY]:</h5>‚ÄûSYNTHOMA ‚Äì NULL je cyberpunkov√° kniha o terapii, vinƒõ a touze po smyslu ve svƒõtƒõ, kde v≈°echno d≈Øle≈æit√© nƒõkdo zalogoval a pak zapomnƒõl heslo.‚Äú
<h5 class= "glitch">LOG [HELP]:</h5>‚ÄûPot√≠≈æe s existenc√≠? Klidnƒõ pokraƒçuj ve ƒçten√≠. Syst√©m tƒõ v tom nenech√° samotn√©ho. P≈ôinejhor≈°√≠m dostane≈° vtipnou pozn√°mku od AI.‚Äú  
<a href="kniha.html" class="button-simple" style="cursor: pointer;">Klikni pro vlastn√≠ restart</a>
      
`;
    
    const target = document.getElementById('myGlitchText');
    target.innerHTML = ''; // Pr√°zdn√©
    typewriterParagraphs(target, fullText, {
            speedMin: 13,
            speedMax: 46,
            paragraphPause: 240
        }, () => {
            gentleGlitchify(target, {
                delayMin: 1400,
                delayMax: 2900,
                glitchDuration: 90,
                glitchChance: 0.07
            });
        });
    }
);

function getGlitchChar(char) {
    const glitchSet = ['', 'N', 'Y', 'H', 'S', 'M', 'T','#', '¬§', '%', '&', '@', '¬ß', '√∑', '√ó', '¬§', '‚ñë', '‚ñí', '‚ñì', '‚ñà', '‚ñÑ', '‚ñÄ', '‚óè', '‚óä', 'O', '|', '/', '\\', '_', '-', '^', '~', '.', '*', '+'];
    if (Math.random() < 0.95) {
        return glitchSet[Math.floor(Math.random() * glitchSet.length)];
    }
    return char;
}

function gentleGlitchify(element, options = {}) {
    const delayMin = options.delayMin || 1500;
    const delayMax = options.delayMax || 3500;
    const glitchDuration = options.glitchDuration || 80;
    const glitchChance = options.glitchChance || 0.08;

    // Najdi v≈°echny textov√© uzly (rekurzivnƒõ!)
    function getTextNodes(node) {
        let textNodes = [];
        if (node.nodeType === 3) { // text node
            textNodes.push(node);
        } else if (node.nodeType === 1 && node.childNodes) {
            node.childNodes.forEach(child => textNodes = textNodes.concat(getTextNodes(child)));
        }
        return textNodes;
    }

    const textNodes = getTextNodes(element);

    // Rozdƒõl v≈°echny textov√© uzly na spany, pokud u≈æ nejsou!
    textNodes.forEach(node => {
        const parent = node.parentNode;
        const fragment = document.createDocumentFragment();
        const chars = node.textContent.split('');
        chars.forEach(char => {
            const span = document.createElement('span');
            if (char === ' ') span.innerHTML = '¬†';
            else span.textContent = char;
            span.classList.add('glitch-char');
            span.dataset.original = char;
            fragment.appendChild(span);
        });
        parent.replaceChild(fragment, node);
    });

    // Teƒè v≈°echny .glitch-char uvnit≈ô elementu
    const chars = element.querySelectorAll('.glitch-char');

    function randomGlitch() {
        let num = 1 + Math.floor(Math.random() * 2);
        for (let i = 0; i < num; i++) {
            let idx, guard = 0;
            do {
                idx = Math.floor(Math.random() * chars.length);
                guard++;
                if (guard > 10) break;
            } while (
                chars[idx].textContent === ' ' ||
                chars[idx].classList.contains('glitchy')
            );
            const span = chars[idx];
            if (Math.random() < glitchChance) {
                const orig = span.dataset.original;
                span.textContent = getGlitchChar(orig);
                span.classList.add('glitchy');
                setTimeout(() => {
                    span.textContent = orig;
                    span.classList.remove('glitchy');
                }, glitchDuration + Math.random()*glitchDuration);
            }
        }
        const next = delayMin + Math.random() * (delayMax - delayMin);
        setTimeout(randomGlitch, next);
    }
    randomGlitch();
}

function getGentleGlitchChar(char) {
    const safe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    if (safe.includes(char)) {
        return safe[Math.floor(Math.random() * safe.length)];
    } else {
        const glitchSet = ['¬§', '*', '#', '@', '&', '/', '_', '|', '-', '~', '.', '+'];
        return glitchSet[Math.floor(Math.random() * glitchSet.length)];
    }
}
