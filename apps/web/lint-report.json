[{"filePath":"C:\\SYNTHOMA\\apps\\web\\app\\api\\books\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\app\\audit\\page.tsx","messages":[{"ruleId":"@typescript-eslint/consistent-type-definitions","severity":2,"message":"Use an `interface` instead of a `type`.","line":5,"column":6,"nodeType":"Identifier","messageId":"interfaceOverType","endLine":5,"endColumn":11,"fix":{"range":[70,148],"text":"interface Check { id: string; label: string; ok: boolean | null; note?: string }"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use client';\n\nimport { useEffect, useMemo, useState } from 'react';\n\ntype Check = { id: string; label: string; ok: boolean | null; note?: string };\n\nconst THEMES = ['synthoma','green-matrix','neon-hellfire','cyber-dystopia','acid-glitch','retro-arcade'] as const;\nconst CSS_VARS_REQUIRED = [\n  '--text-primary','--text-secondary','--bg-secondary','--border-secondary',\n  '--accent-primary','--accent-secondary','--glow-primary','--glow-secondary'\n];\nconst CSS_SELECTORS_REQUIRED = [\n  '.panel','.btn','.halo','.glitch-title','.scramble-title','.video-background','#glitch-bg','#noise-canvas','.fx-glitch'\n];\n\nexport default function AuditPage() {\n  const [checks, setChecks] = useState<Check[]>([]);\n  const [currentTheme, setCurrentTheme] = useState<string>('');\n  const [noAnim, setNoAnim] = useState<boolean>(false);\n  const [videoReport, setVideoReport] = useState<string>('');\n\n  const root = useMemo(() => (typeof document !== 'undefined' ? document.documentElement : null), []);\n\n  useEffect(() => {\n    const results: Check[] = [];\n\n    // 1) Layout anchors\n    const anchors = ['toaster','modal-run','noise-canvas'];\n    anchors.forEach(id => {\n      const el = typeof document !== 'undefined' ? document.getElementById(id) : null;\n      results.push({ id: `anchor:${id}`, label: `Anchor #${id}`, ok: !!el, note: el ? 'OK' : 'missing' });\n    });\n    const vb = typeof document !== 'undefined' ? document.querySelector('.video-background') : null;\n    const gb = typeof document !== 'undefined' ? document.getElementById('glitch-bg') : null;\n    results.push({ id: 'anchor:video-background', label: 'Video background container', ok: !!vb });\n    results.push({ id: 'anchor:glitch-bg', label: 'Glitch canvas #glitch-bg', ok: !!gb });\n\n    // 2) CSS variables presence for current theme\n    const style = root ? getComputedStyle(root) : (null as any);\n    CSS_VARS_REQUIRED.forEach(v => {\n      const val = style ? style.getPropertyValue(v) : '';\n      results.push({ id: `var:${v}`, label: `CSS var ${v}`, ok: !!val && val.trim() !== '' , note: (val||'').trim() || 'unset' });\n    });\n\n    // 3) Selectors existence (rough)\n    const foundSelectors: string[] = [];\n    try {\n      for (const sheet of Array.from(document.styleSheets) as CSSStyleSheet[]) {\n        // Ignore cross-origin\n        let rules: any;\n        try { rules = sheet.cssRules; } catch { continue; }\n        if (!rules) continue;\n        for (const r of Array.from(rules) as CSSRule[]) {\n          const t = r as CSSStyleRule;\n          if ((t as any).selectorText) foundSelectors.push((t as any).selectorText);\n        }\n      }\n    } catch {}\n    CSS_SELECTORS_REQUIRED.forEach(sel => {\n      const ok = foundSelectors.some(s => s.split(',').some(x => x.trim() === sel));\n      results.push({ id: `selector:${sel}`, label: `Selector ${sel}`, ok });\n    });\n\n    // 4) prefers-reduced-motion + .no-animations behavior (best-effort)\n    const prm = (()=>{ try { return matchMedia('(prefers-reduced-motion: reduce)').matches; } catch { return false; } })();\n    results.push({ id: 'motion:prefers-reduced', label: 'prefers-reduced-motion respected', ok: typeof prm === 'boolean' });\n\n    // 5) Themes variability: check that at least one key var differs across themes\n    let distinctThemes = 0;\n    const sampleVar = '--accent-primary';\n    const seen = new Set<string>();\n    THEMES.forEach(t => {\n      root?.setAttribute('data-theme', t);\n      const v = getComputedStyle(root as Element).getPropertyValue(sampleVar).trim();\n      if (v) seen.add(v);\n    });\n    distinctThemes = seen.size;\n    // Restore body data-theme via setTheme if available\n    const saved = (typeof localStorage !== 'undefined' ? localStorage.getItem('theme') : null) || 'synthoma';\n    document.body?.setAttribute('data-theme', saved);\n    results.push({ id: 'themes:variance', label: 'Themes change CSS vars', ok: distinctThemes > 1, note: `${sampleVar} variants: ${distinctThemes}` });\n\n    setChecks(results);\n    setCurrentTheme(document.body?.getAttribute('data-theme') || 'synthoma');\n    setNoAnim(document.body?.classList.contains('no-animations') || false);\n  }, [root]);\n\n  // Probe videos\n  useEffect(() => {\n    let cancelled = false;\n    (async () => {\n      const paths = Array.from({ length: 10 }, (_, i) => `/video/SYNTHOMA${i+1}.mp4`);\n      let ok = 0, fail = 0;\n      for (const p of paths) {\n        try {\n          const res = await fetch(p, { method: 'HEAD' });\n          if (res.ok) ok++; else fail++;\n        } catch {\n          fail++;\n        }\n      }\n      if (!cancelled) setVideoReport(`${ok} OK / ${fail} missing`);\n    })();\n    return () => { cancelled = true; };\n  }, []);\n\n  const toggleNoAnim = () => {\n    document.body.classList.toggle('no-animations');\n    setNoAnim(document.body.classList.contains('no-animations'));\n  };\n\n  const cycleTheme = () => {\n    const idx = THEMES.indexOf(currentTheme as any);\n    const next = THEMES[(idx + 1) % THEMES.length];\n    (window as any).setTheme?.(next);\n    document.body.setAttribute('data-theme', next);\n    try { localStorage.setItem('theme', next); } catch {}\n    setCurrentTheme(next);\n  };\n\n  return (\n    <main style={{ padding: 16 }}>\n      <section className=\"panel fx-noise\" style={{ padding: 16, marginBottom: 12 }}>\n        <h1 className=\"glitch-title\" data-glitch=\"soft\">Style & Effects Audit</h1>\n        <p className=\"text\">Tvoje CSS devadesátky volají, chtějí víc proměnných. Zkontrolovali jsme pár banalit, jestli se to celý nezhroutí.</p>\n        <div style={{ display:'flex', gap:8, marginTop:8 }}>\n          <button className=\"btn\" onClick={cycleTheme}>Přepnout motiv ({currentTheme})</button>\n          <button className=\"btn\" onClick={toggleNoAnim}>{noAnim ? 'Zapnout animace' : 'Vypnout animace'}</button>\n          <span className=\"text-muted\" style={{ marginLeft: 'auto' }}>Video assets: {videoReport || '…'}</span>\n        </div>\n      </section>\n\n      <section className=\"panel fx-noise\" style={{ padding: 16 }}>\n        <h2 className=\"halo\">Kontroly</h2>\n        <ul style={{ listStyle:'none', padding: 0, marginTop: 8, display:'grid', gap: 6 }}>\n          {checks.map(c => (\n            <li key={c.id} className=\"glass\" style={{ padding: 8, borderRadius: 8, display:'flex', gap:8, alignItems:'baseline', border:'1px solid var(--border-tertiary)' }}>\n              <span style={{ minWidth: 22, textAlign:'center' }}>{c.ok ? '✅' : c.ok === false ? '❌' : '…'}</span>\n              <span>{c.label}</span>\n              {c.note ? <span className=\"text-muted\" style={{ marginLeft: 'auto' }}>{c.note}</span> : null}\n            </li>\n          ))}\n        </ul>\n      </section>\n\n      <p className=\"text-muted\" style={{ marginTop: 8 }}>\n        Pokud chceš přidat další kontroly (např. validaci hodnot proměnných, dostupnost fontů, A11y průchod), pískni. Přidáme bez zbytečného moralizování.\n      </p>\n    </main>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\app\\end\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\app\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'runCinematicButtonIntro' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startBodyTypingFromHtml' is defined but never used.","line":8,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'glitchTimerRef' is assigned a value but never used.","line":28,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'titleIntroTimers' is assigned a value but never used.","line":29,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'btnIntroTimers' is assigned a value but never used.","line":30,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'router' is assigned a value but never used.","line":32,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":142,"column":29,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":142,"endColumn":108},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":159,"column":13,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":159,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":160,"column":13,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":160,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":161,"column":13,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":161,"endColumn":90},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'scrollTerminalBottom' is assigned a value but never used.","line":165,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":165,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":382,"column":13,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":382,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":383,"column":13,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":383,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":590,"column":15,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":590,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":591,"column":15,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":591,"endColumn":78},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":648,"column":11,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":648,"endColumn":74},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":700,"column":36,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":700,"endColumn":101}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { runCinematicTitleIntro } from \"@web/lib/cinematicTitle\";\nimport { runCinematicButtonIntro } from \"@web/lib/cinematicButton\";\nimport { getSharedAudio } from \"@web/lib/audio\";\nimport { runTypewriter, startBodyTypingFromHtml, typeExternalInfo, typeBooksList } from \"@web/lib/typewriter\";\nimport \"@web/styles/reader.css\";\n\nconst TITLE = \"SYNTHOMA\";\nconst MANIFEST = \"Tma nikdy není opravdová, je jen světlem, které se vzdalo smyslu.\";\nconst BTN_LABEL = \"Pokračovat\";\n\nexport default function HomePage() {\n  const [showTitle, setShowTitle] = useState(false);\n  const [showManifest, setShowManifest] = useState(false);\n  const [typedDone, setTypedDone] = useState(false);\n  const [btnVisible, setBtnVisible] = useState(false);\n  const [showReader, setShowReader] = useState(false);\n  const [showReaderDetails, setShowReaderDetails] = useState(false);\n  const [controlsVisible, setControlsVisible] = useState(false);\n  // Ochrany proti dvojímu spuštění efektů v React 18 StrictMode (dev)\n  const readerIntroRanRef = useRef(false);\n  const readerSeqRanRef = useRef(false);\n  const [isAudioPlaying, setIsAudioPlaying] = useState(false);\n  const glitchRootRef = useRef<HTMLDivElement | null>(null);\n  const glitchTimerRef = useRef<number | null>(null);\n  const titleIntroTimers = useRef<number[]>([]);\n  const btnIntroTimers = useRef<number[]>([]);\n  const audioRef = useRef<HTMLAudioElement | null>(null);\n  const router = useRouter();\n  const btnGlitchRef = useRef<HTMLButtonElement | null>(null);\n  const isStartingAudioRef = useRef(false);\n\n  // Handlery pro tlačítka – využij knihovnu z src/lib/typewriter.ts\n  const handleInfoClick = () => { typeExternalInfo().catch((e) => console.error('INFO failed', e)); };\n  const handleBooksClick = () => { typeBooksList().catch((e) => console.error('Books failed', e)); };\n\n  // Orchestrace: nejdřív rozglitchovaný vstup nadpisu (4s intro), pak manifest s typewriterem\n  useEffect(() => {\n    // drobná prodleva na mount pro plynulejší přechod\n    const t1 = window.setTimeout(() => setShowTitle(true), 30);\n    // manifest po dojetí 4s intra (malý nádech navíc kvůli layout/paint): ~4.1s\n    const t2 = window.setTimeout(() => setShowManifest(true), 4100);\n    return () => { window.clearTimeout(t1); window.clearTimeout(t2); };\n  }, []);\n\n  // CSS přesunuto do src/styles/reader.css (žádné injektování stylů v runtime)\n\n  // (reverted) Globální skrývání scrollbarů odstraněno – způsobovalo vedlejší efekty\n\n  // Typewriter pro čtečku/terminál po kliknutí na Pokračovat\n  useEffect(() => {\n    if (!showReader) {\n      // reset guardů při odchodu z readeru\n      readerIntroRanRef.current = false;\n      readerSeqRanRef.current = false;\n      return;\n    }\n    // Zamez dvojitému spuštění v dev/StrictMode\n    if (readerIntroRanRef.current) return;\n    readerIntroRanRef.current = true;\n    // Každý vstup do readeru začíná bez detailů; detail zobrazíme až po dopsání dialogu\n    setShowReaderDetails(false);\n    setControlsVisible(false);\n    const logHost = document.querySelector('#reader-log') as HTMLElement | null;\n    const dialogHost = document.querySelector('#reader-dialog') as HTMLElement | null;\n    if (!logHost || !dialogHost) return;\n    // Připrav cílové span prvky, podobně jako u tlačítka\n    function ensureTarget(h: HTMLElement){\n      let span = h.querySelector('.noising-text') as HTMLElement | null;\n      if (!span) {\n        span = document.createElement('span');\n        span.className = 'noising-text';\n        h.appendChild(span);\n      } else { span.textContent = ''; }\n      return span;\n    }\n    if (logHost) ensureTarget(logHost as HTMLElement);\n    if (dialogHost) ensureTarget(dialogHost as HTMLElement);\n\n    let cancelLog: (() => void) | null = null;\n    let cancelDialog: (() => void) | null = null;\n\n    // Napiš nejdřív LOG, pak dialog\n    cancelLog = runTypewriter({\n      text: 'LOG: [SYSTEM BOOT]',\n      host: logHost,\n      getDurationMs: () => 1400,\n      onStart: () => { /* no-op */ return; },\n      onDone: () => {\n        cancelDialog = runTypewriter({\n          text: '„Vítej v SYNTHOMĚ, @&SĐYŁ !!!  Tady tvé jméno nikoho nezajímá, ale tvé chyby? Ty si pamatujeme věčně.“',\n          host: dialogHost,\n          getDurationMs: () => {\n            // zarovnat tempo k manifestu, ale trochu rychlejší\n            const mw = document.getElementById('manifest-container');\n            if (mw) {\n              const cs = getComputedStyle(mw);\n              const durVar = cs.getPropertyValue('--typewriter-duration').trim();\n              if (durVar.endsWith('ms')) return parseFloat(durVar) * 0.7;\n              if (durVar.endsWith('s')) return parseFloat(durVar) * 1000 * 0.7;\n            }\n            return 5200;\n          },\n          onStart: () => {\n            // Najdi cílové termy z a11y obsahu: .sr-only .glitching (libovolné výskyty)\n            const glitchTerms = Array.from(dialogHost.querySelectorAll('.sr-only .glitching'))\n              .map(n => (n as HTMLElement).textContent || '')\n              .filter(t => t && t.trim().length > 0);\n            if (!glitchTerms.length) return;\n            let tries = 0;\n            const maxTries = 220; // ~26s při 120ms\n            const doneTerms = new Set<string>();\n            const poll = window.setInterval(() => {\n              tries++;\n              try {\n                const span = dialogHost.querySelector('.noising-text') as HTMLElement | null;\n                if (!span) return;\n                const chars = Array.from(span.querySelectorAll('.tw-char')) as HTMLElement[];\n                if (!chars.length) return;\n                const textNow = chars.map(c => c.textContent || '').join('');\n                for (const term of glitchTerms) {\n                  if (doneTerms.has(term)) continue;\n                  const idx = textNow.indexOf(term);\n                  if (idx !== -1) {\n                    // Vlož wrapper před první znak termu\n                    const wrap = document.createElement('span');\n                    wrap.className = 'glitching';\n                    const first = chars[idx] as HTMLElement | undefined;\n                    const parent = first && first.parentNode as HTMLElement | null;\n                    if (parent && first) {\n                      parent.insertBefore(wrap, first);\n                      // Původní znaky skryj, aby finalizační fáze typewriteru nepřekreslila text vizuálně podruhé\n                      for (let i = 0; i < term.length && (idx + i) < chars.length; i++) {\n                        const el = chars[idx + i];\n                        if (el) el.classList.add('tw-char-hidden');\n                      }\n                      // Nastav viditelný text do wrapperu (glitch engine jej interně rozdělí)\n                      wrap.textContent = term;\n                      try { (window as any).startGlitching && (window as any).startGlitching('.glitching'); } catch {}\n                      doneTerms.add(term);\n                    }\n                  }\n                }\n                // hotovo pro všechny termy\n                if (doneTerms.size === glitchTerms.length) { window.clearInterval(poll); }\n              } catch {}\n              if (tries > maxTries) { try { window.clearInterval(poll); } catch {} }\n            }, 120) as unknown as number;\n          },\n          onDone: () => { setShowReaderDetails(true); }\n        });\n      }\n    });\n\n    return () => {\n      try { cancelLog && cancelLog(); } catch {}\n      try { cancelDialog && cancelDialog(); } catch {}\n      try { (window as any).stopGlitching && (window as any).stopGlitching('.glitching'); } catch {}\n    };\n\n    // Terminálový auto-scroll dolů, když přibude řádek\n    const scrollTerminalBottom = () => {\n      try { window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' }); } catch {}\n    };\n  }, [showReader]);\n\n  // Po dokončení úvodního dialogu napiš celý zbytek obsahu čtečky sekvenčně\n  useEffect(() => {\n    if (!showReader || !showReaderDetails) return;\n    // Zamez dvojitému spuštění v dev/StrictMode\n    if (readerSeqRanRef.current) return;\n    readerSeqRanRef.current = true;\n    // 1) Titulek\n    const titleHost = document.querySelector('#reader-title') as HTMLElement | null;\n    const bodyHost = document.querySelector('#reader-body') as HTMLElement | null;\n    const userLogHost = document.querySelector('#reader-log') as HTMLElement | null;\n    const userDialogHost = document.querySelector('#reader-dialog') as HTMLElement | null;\n    if (!titleHost || !userLogHost || !userDialogHost) {\n      console.log('typewriter: missing hosts', {\n        title: !!titleHost, body: !!bodyHost, userLog: !!userLogHost, userDialog: !!userDialogHost\n      });\n      return;\n    }\n\n    // Lokální helper: posuň stránku na spodek (page-level scroll)\n    const scrollTerminalBottom = () => {\n      try { window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' }); } catch {}\n    };\n\n    function ensureTarget(h: HTMLElement){\n      let span = h.querySelector('.noising-text') as HTMLElement | null;\n      if (!span) {\n        span = document.createElement('span');\n        span.className = 'noising-text';\n        // zachovej zalomení řádků během psaní\n        (span.style as any).whiteSpace = 'pre-wrap';\n        (span.style as any).display = 'block';\n        h.appendChild(span);\n      } else {\n        // Nemazat existující obsah – historie musí zůstat. Jen pojistit styly.\n        (span.style as any).whiteSpace = 'pre-wrap';\n        (span.style as any).display = 'block';\n      }\n      return span;\n    }\n    if (titleHost) ensureTarget(titleHost as HTMLElement);\n    if (bodyHost) ensureTarget(bodyHost as HTMLElement);\n\n    // Získej text k vypsání s podporou zalomení: extrahuj z rich-hidden HTML a nahraď <br> za \\n, ukončení bloků za \\n\\n\n    const getHostText = (h: HTMLElement) => {\n      const rich = h.querySelector('.rich-hidden') as HTMLElement | null;\n      const normalize = (raw: string) => raw\n        .replace(/&nbsp;|&#160;/gi, ' ')\n        .replace(/\\r\\n?/g, '\\n');\n      if (rich) {\n        const rawHtml = rich.innerHTML || '';\n        const html = normalize(rawHtml);\n        let text = html\n          .replace(/<br\\s*\\/>?/gi, '\\n')\n          .replace(/<\\/(p|div|h[1-6]|li)>/gi, '</$1>\\n')\n          .replace(/<li[^>]*>/gi, '• ')\n          .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n          .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n          .replace(/<[^>]+>/g, '')\n          .replace(/[\\t ]+\\n/g, '\\n')\n          .replace(/\\n{3,}/g, '\\n\\n')\n          .trim();\n        if (!text) {\n          // fallback: použij textContent bohatého bloku\n          text = normalize(rich.textContent || '').trim();\n        }\n        return text;\n      }\n      const s = h.querySelector('.sr-only') as HTMLElement | null;\n      return s ? normalize(s.textContent || '').trim() : '';\n    };\n\n    // Po dopsání nahraď obsah bohatým HTML z hidden kontejneru (pokud existuje)\n    const swapInRich = (host: HTMLElement) => {\n      const rich = host.querySelector('.rich-hidden') as HTMLElement | null;\n      if (rich) {\n        // Zachovej host, ale vyměň jeho vnitřek za rich children\n        host.innerHTML = rich.innerHTML;\n        try {\n          const sg = (window as any).startGlitching;\n          // Inicializuj glitch pouze pro nové prvky (idempotentně)\n          const nodes = host.querySelectorAll('.glitch-master, .glitching');\n          const toInit: HTMLElement[] = [];\n          nodes.forEach((el) => {\n            const d = (el as HTMLElement).dataset as any;\n            if (!d || !d.glitchInit) {\n              (el as HTMLElement).classList.add('glitch-to-init');\n              if (d) d.glitchInit = '1';\n              toInit.push(el as HTMLElement);\n            }\n          });\n          if (toInit.length && typeof sg === 'function') {\n            sg('.glitch-to-init');\n            toInit.forEach((el) => el.classList.remove('glitch-to-init'));\n          }\n        } catch {}\n      }\n    };\n\n    let cancel1: null | (() => void) = null;\n    let cancel2: null | (() => void) = null;\n\n    cancel1 = runTypewriter({\n      text: getHostText(titleHost),\n      host: titleHost,\n      getDurationMs: () => 1400,\n      onStart: () => { /* no-op before typing CTA */ return; },\n      onDone: () => {\n        // Zpřístupni reader-controls až po dopsání titulku, stejně jako CTA po manifestu\n        setControlsVisible(true);\n        swapInRich(titleHost);\n        // Pokud není bodyHost, skonči – log/dialog už byly vypsány v první fázi\n        if (!bodyHost) { console.log('typewriter: no bodyHost, skipping body and not repeating log/dialog'); return; }\n        console.log('typewriter: title done, starting body');\n        // Line-by-line typing for body\n        const fullText = getHostText(bodyHost);\n        console.log('typewriter: body fullText', { len: fullText.length, sample: fullText.slice(0, 120) });\n        let lines = fullText.split(/\\n/);\n        if (lines.length <= 1 && fullText.length > 300) {\n          // Heuristicky rozsekej na věty, když nejsou newline\n          lines = fullText.split(/\\n|(?<=[\\.!?…])\\s+(?=[A-ZÁ-Ž0-9„(])/u);\n        }\n        if (!fullText || !fullText.trim()) {\n          // žádné tělo? nic dalšího nespouštěj – log/dialog už proběhly v první fázi\n          console.log('typewriter: body empty, skipping without repeating log/dialog');\n          return;\n        }\n        let container = bodyHost.querySelector('.noising-text') as HTMLElement | null;\n        if (!container) {\n          // vytvoř kontejner, pokud nějaký chytrák v DOMu zmizel\n          container = document.createElement('span');\n          container.className = 'noising-text';\n          bodyHost.appendChild(container);\n        }\n        if (container) {\n          // Nemaž obsah – čtečka se musí zvětšovat a historie zůstávat\n          (container.style as any).whiteSpace = 'pre-wrap';\n          (container.style as any).display = 'block';\n        }\n        console.log('typewriter: body start', { lines: lines.length, sample: lines.slice(0,3) });\n\n        const computeTotalDuration = () => {\n          const mw = document.getElementById('manifest-container');\n          if (mw) {\n            const cs = getComputedStyle(mw);\n            const durVar = cs.getPropertyValue('--typewriter-duration').trim();\n            if (durVar.endsWith('ms')) return parseFloat(durVar) * 3.5;\n            if (durVar.endsWith('s')) return parseFloat(durVar) * 1000 * 3.5;\n          }\n          return 24000;\n        };\n\n        const totalDuration = computeTotalDuration();\n        const lengths = lines.map(l => l.length || 1);\n        const totalChars = lengths.reduce((a,b)=>a+b,0) || 1;\n        const cancels: (null | (()=>void))[] = [];\n        let aborted = false;\n\n        const startLine = (idx: number, onAllDone: () => void) => {\n          if (aborted) return;\n          if (idx >= lines.length) { onAllDone(); return; }\n          const text = lines[idx];\n          const lineEl = document.createElement('span');\n          (lineEl.style as any).whiteSpace = 'pre-wrap';\n          (lineEl.style as any).display = 'block';\n          if (container) {\n            container.appendChild(lineEl);\n            scrollTerminalBottom();\n          }\n          const share = lengths[idx] / totalChars;\n          // základ z celkové doby + rozumné omezení per-line, ať první megařádek netrvá věčně\n          let dur = Math.max(250, Math.round(totalDuration * share));\n          const perChar = Math.min(5000, Math.max(250, (text.length || 1) * 22));\n          dur = Math.min(dur, perChar);\n          if (idx === 0) {\n            try { console.log('typewriter: body line0', { len: text.length, dur }); } catch {}\n          }\n          // Pokud je řádek prázdný/whitespace, jen vlož prázdný blok a pokračuj\n          if (!text || text.trim() === '') {\n            // malá pauza pro rytmus\n            window.setTimeout(() => startLine(idx + 1, onAllDone), 10);\n            return;\n          }\n          const cancel = runTypewriter({\n            text,\n            host: lineEl,\n            getDurationMs: () => dur,\n            onStart: () => { /* no-op before typing button label */ return; },\n            onDone: () => { scrollTerminalBottom(); startLine(idx + 1, onAllDone); }\n          });\n          cancels.push(cancel);\n        };\n\n        // Expose a cancel for the whole body sequence\n        cancel2 = () => {\n          aborted = true;\n          try { cancels.forEach(c => c && c()); } catch {}\n        };\n\n        try {\n          startLine(0, () => {\n            if (!aborted) {\n              // Po dopsání těla nic neopakuj – log/dialog už proběhly v první fázi\n              scrollTerminalBottom();\n            }\n          });\n        } catch (err) {\n          console.error('typewriter: body sequence error', err);\n        }\n      }\n    });\n\n    return () => {\n      try { cancel1 && cancel1(); } catch {}\n      try { cancel2 && cancel2(); } catch {}\n    };\n  }, [showReader, showReaderDetails]);\n\n  // Popup-tip: delegované tooltipy (short na hover, long po kliku) s čištěním\n  useEffect(() => {\n    if (typeof window === 'undefined' || typeof document === 'undefined') return;\n\n    let popupElement: HTMLDivElement | null = null;\n    let longTextTimeout: ReturnType<typeof setTimeout> | null = null;\n    let currentTip: HTMLElement | null = null;\n\n    const updatePopupPosition = (event: MouseEvent) => {\n      if (!popupElement) return;\n      const padding = 10;\n      const popupWidth = popupElement.offsetWidth;\n      const popupHeight = popupElement.offsetHeight;\n      const viewportWidth = window.innerWidth;\n      const viewportHeight = window.innerHeight;\n\n      let x = event.clientX + 15;\n      let y = event.clientY + 15;\n\n      if (x + popupWidth + padding > viewportWidth) {\n        x = viewportWidth - popupWidth - padding;\n      }\n      if (x < padding) x = padding;\n\n      if (y + popupHeight + padding > viewportHeight) {\n        y = viewportHeight - popupHeight - padding;\n      }\n      if (y < padding) y = padding;\n\n      popupElement.style.left = `${x}px`;\n      popupElement.style.top = `${y}px`;\n    };\n\n    const hidePopup = () => {\n      if (popupElement) {\n        popupElement.remove();\n        popupElement = null;\n      }\n      if (longTextTimeout) {\n        clearTimeout(longTextTimeout);\n        longTextTimeout = null;\n      }\n      document.removeEventListener('mousemove', updatePopupPosition as any);\n      window.removeEventListener('scroll', hidePopup as any);\n      currentTip = null;\n    };\n\n    const showPopup = (targetElement: HTMLElement, event: MouseEvent) => {\n      if (popupElement) hidePopup();\n      const shortText = (targetElement as any).dataset?.short as string | undefined;\n      const longText = (targetElement as any).dataset?.long as string | undefined;\n      if (!shortText) {\n        console.warn('popup-tip: chybí data-short');\n        return;\n      }\n      console.debug('popup-tip: show', { shortText, longText, target: targetElement });\n\n      popupElement = document.createElement('div');\n      popupElement.className = 'popup-container';\n      popupElement.style.position = 'fixed';\n      popupElement.style.pointerEvents = 'none';\n      popupElement.style.opacity = '0';\n      popupElement.style.zIndex = '3000';\n\n      const content = document.createElement('p');\n      content.className = 'popup-text';\n      content.textContent = shortText;\n      popupElement.appendChild(content);\n      document.body.appendChild(popupElement);\n\n      updatePopupPosition(event);\n      popupElement.style.opacity = '1';\n\n      document.addEventListener('mousemove', updatePopupPosition as any);\n      window.addEventListener('scroll', hidePopup as any, { once: true } as any);\n\n      if (longText) {\n        longTextTimeout = setTimeout(() => {\n          if (popupElement) {\n            const p = popupElement.querySelector('.popup-text') as HTMLElement | null;\n            if (p) p.textContent = longText;\n            updatePopupPosition(event);\n          }\n        }, 3500);\n      }\n    };\n\n    const showLongTextOnClick = (targetElement: HTMLElement, event: MouseEvent) => {\n      if (!popupElement) showPopup(targetElement, event);\n      const longText = (targetElement as any).dataset?.long as string | undefined;\n      if (longText && popupElement) {\n        if (longTextTimeout) {\n          clearTimeout(longTextTimeout);\n          longTextTimeout = null;\n        }\n        const p = popupElement.querySelector('.popup-text') as HTMLElement | null;\n        if (p) p.textContent = longText;\n        updatePopupPosition(event);\n      }\n    };\n    \n    const onMouseMove = (ev: Event) => {\n      const e = ev as MouseEvent;\n      let tip = (e.target as HTMLElement)?.closest('.popup-tip') as HTMLElement | null;\n      if (!tip) {\n        // Některé glitch overlay vrstvy mohou blokovat hit-test. Dočasně je vypneme.\n        const overlays = (Array.from(document.querySelectorAll('[class*=\"glitch\"]')) as HTMLElement[])\n          .filter(el => !el.closest('.popup-tip'));\n        const prevPE: [HTMLElement, string][] = [];\n        overlays.forEach(el => { prevPE.push([el, el.style.pointerEvents]); el.style.pointerEvents = 'none'; });\n        try {\n          const el = document.elementFromPoint(e.clientX, e.clientY) as HTMLElement | null;\n          tip = el ? (el.closest('.popup-tip') as HTMLElement | null) : null;\n        } finally {\n          prevPE.forEach(([el, pe]) => { el.style.pointerEvents = pe; });\n        }\n      }\n      if (tip !== currentTip) {\n        if (currentTip) hidePopup();\n        if (tip) showPopup(tip, e);\n        currentTip = tip;\n      }\n      if (popupElement) updatePopupPosition(e);\n    };\n\n    const onPointerEnter = (ev: Event) => {\n      const e = ev as PointerEvent;\n      const tip = (e.target as HTMLElement)?.closest('.popup-tip') as HTMLElement | null;\n      if (tip) {\n        currentTip = tip;\n        showPopup(tip, e as any as MouseEvent);\n      }\n    };\n\n    const onPointerLeave = (ev: Event) => {\n      const e = ev as PointerEvent;\n      const tip = (e.target as HTMLElement)?.closest('.popup-tip') as HTMLElement | null;\n      if (tip && tip === currentTip) {\n        hidePopup();\n        currentTip = null;\n      }\n    };\n\n    const onClick = (ev: Event) => {\n      const e = ev as MouseEvent;\n      const target = currentTip || ((e.target as HTMLElement)?.closest('.popup-tip') as HTMLElement | null);\n      if (target) showLongTextOnClick(target, e);\n    };\n\n    document.body.addEventListener('mousemove', onMouseMove as any);\n    document.body.addEventListener('pointerenter', onPointerEnter as any, true);\n    document.body.addEventListener('pointerleave', onPointerLeave as any, true);\n    document.body.addEventListener('click', onClick as any);\n\n    return () => {\n      hidePopup();\n      document.body.removeEventListener('mousemove', onMouseMove as any);\n      document.body.removeEventListener('pointerenter', onPointerEnter as any, true);\n      document.body.removeEventListener('pointerleave', onPointerLeave as any, true);\n      document.body.removeEventListener('click', onClick as any);\n    };\n  }, []);\n\n  // Typewriter pro tlačítko \"Pokračovat\" – stejné efekty jako manifest\n  useEffect(() => {\n    if (!btnVisible) return;\n    const btn = btnGlitchRef.current as HTMLButtonElement | null;\n    if (!btn) return;\n    const host = btn.querySelector('.glitch-real') as HTMLElement | null;\n    if (!host) return;\n    // Zajistíme, že máme cílový span pro psaní\n    let span = host.querySelector('.noising-text') as HTMLElement | null;\n    if (!span) {\n      span = document.createElement('span');\n      span.className = 'noising-text';\n      host.appendChild(span);\n    } else {\n      span.textContent = '';\n    }\n    // Vyprázdni fake vrstvy během psaní, ať neprozrazují text\n    const f1 = btn.querySelector('.glitch-fake1') as HTMLElement | null;\n    const f2 = btn.querySelector('.glitch-fake2') as HTMLElement | null;\n    if (f1) f1.textContent = '';\n    if (f2) f2.textContent = '';\n    const cancel = runTypewriter({\n      text: BTN_LABEL,\n      host,\n      getDurationMs: () => {\n        // použij stejné tempo jako manifest (fallback 2200ms pro kratší text)\n        const mw = document.getElementById('manifest-container');\n        if (mw) {\n          const cs = getComputedStyle(mw);\n          const durVar = cs.getPropertyValue('--typewriter-duration').trim();\n          if (durVar.endsWith('ms')) return parseFloat(durVar) * 0.35; // kratší label, zrychlíme\n          if (durVar.endsWith('s')) return parseFloat(durVar) * 1000 * 0.35;\n        }\n        return 2200;\n      },\n      onStart: () => { /* no-op before typing CTA button */ return; },\n      onDone: () => {\n        // po dopsání naplň fake vrstvy pro hover glitch\n        if (f1) f1.textContent = BTN_LABEL;\n        if (f2) f2.textContent = BTN_LABEL;\n        try { (window as any).startShinning && (window as any).startShinning(); } catch {}\n        try { (window as any).startNoising && (window as any).startNoising(); } catch {}\n      },\n    });\n    return () => { try { cancel(); } catch {} };\n  }, [btnVisible]);\n\n  // Přednačti/pořiď shared audio (bez autoplay)\n  useEffect(() => {\n    try {\n      const a = getSharedAudio('/audio/SynthBachmoff.mp3');\n      audioRef.current = a;\n      // inicializace stavu podle skutečného přehrávání\n      const compute = () => setIsAudioPlaying(() => !!a && !a.paused && !a.ended && a.currentTime > 0);\n      compute();\n      const onPlay = () => setIsAudioPlaying(true);\n      const onPause = () => setIsAudioPlaying(false);\n      const onEnded = () => setIsAudioPlaying(false);\n      a.addEventListener('play', onPlay);\n      a.addEventListener('pause', onPause);\n      a.addEventListener('ended', onEnded);\n      return () => {\n        try {\n          a.removeEventListener('play', onPlay);\n          a.removeEventListener('pause', onPause);\n          a.removeEventListener('ended', onEnded);\n        } catch {}\n      };\n    } catch {}\n  }, []);\n\n  const handleContinue = async () => {\n    try {\n      // Preferuj ovládání přes panel, aby se synchronizovala i UI ikonka\n      const ensure = (window as any).audioPanelEnsurePlaying as undefined | (() => void);\n      if (typeof ensure === 'function') {\n        if (!isStartingAudioRef.current) {\n          isStartingAudioRef.current = true;\n          ensure();\n          sessionStorage.setItem('synthoma_play_audio', '1');\n          setTimeout(() => { isStartingAudioRef.current = false; }, 150);\n        }\n      } else {\n        const a = audioRef.current || getSharedAudio('/audio/SynthBachmoff.mp3');\n        // Spusť hudbu jen pokud skutečně nehraje\n        if (a && (a.paused || a.ended || a.currentTime === 0)) {\n          if (!isStartingAudioRef.current) {\n            isStartingAudioRef.current = true;\n            await a.play().catch(() => { /* autoplay may be blocked */ return; });\n            sessionStorage.setItem('synthoma_play_audio', '1');\n            // reset flag krátce po onplay; play event nasadí isAudioPlaying\n            setTimeout(() => { isStartingAudioRef.current = false; }, 150);\n          }\n        }\n      }\n    } catch {}\n    // Místo přesměrování ukážeme čtečku/terminál na této stránce\n    setShowReader(true);\n    try { (window as any).stopShinning && (window as any).stopShinning(); } catch {}\n  };\n\n  // Cinematic intro pro nadpis – externalizováno\n  useEffect(() => {\n    if (!showTitle) return;\n    const root = glitchRootRef.current as unknown as HTMLElement | null;\n    if (!root) return;\n    const cancel = runCinematicTitleIntro(root);\n    return () => { try { cancel(); } catch {} };\n  }, [showTitle]);\n\n  // Počet kroků pro typewriter podle délky textu\n  const typewriterSteps = useMemo(() => String(MANIFEST.length), []);\n\n  // Nastav CSS proměnnou pro typewriter kroky bez inline JSX stylů\n  useEffect(() => {\n    const el = document.getElementById(\"manifest-container\");\n    if (el) {\n      el.style.setProperty(\"--typewriter-steps\", typewriterSteps);\n      // Zpomalení typewriteru – lze ladit přes CSS proměnné\n      el.style.setProperty(\"--typewriter-duration\", \"7.2s\");\n      el.style.setProperty(\"--caret-duration\", \"1.4s\");\n    }\n  }, [typewriterSteps]);\n\n  // Typewriter: externalizováno do helperu runTypewriter\n  useEffect(() => {\n    if (!showManifest) return;\n    const host = document.getElementById('manifest-container') as HTMLElement | null;\n    if (!host) return;\n    const cancel = runTypewriter({\n      text: MANIFEST,\n      host,\n      getDurationMs: () => {\n        const cs = getComputedStyle(host);\n        const durVar = cs.getPropertyValue('--typewriter-duration').trim();\n        if (durVar.endsWith('ms')) return parseFloat(durVar);\n        if (durVar.endsWith('s')) return parseFloat(durVar) * 1000;\n        return 7200;\n      },\n      onStart: () => setTypedDone(false),\n      onDone: () => setTypedDone(true),\n    });\n    return () => { try { cancel(); } catch {} };\n  }, [showManifest]);\n\n  // Spusť shining až po dokončení psaní (s retry, kdyby helper ještě nebyl načten)\n  useEffect(() => {\n    if (!typedDone) return;\n    if (document.body?.classList.contains('no-animations')) return;\n    let tries = 0;\n    const startNow = () => { try { (window as any).startShinning && (window as any).startShinning(); } catch {} };\n    const id = window.setInterval(() => {\n      tries++;\n      if (typeof (window as any).startShinning === 'function') { startNow(); window.clearInterval(id); }\n      if (tries > 40) { window.clearInterval(id); }\n    }, 50);\n    return () => { window.clearInterval(id); };\n  }, [typedDone]);\n\n  // Post-typing hard fallback: guarantee visible flicker even if helper misbehaves\n  useEffect(() => {\n    if (!typedDone) return;\n    // mírná prodleva, ať tlačítko vstoupí s jemným intrem\n    const id = window.setTimeout(() => setBtnVisible(true), 300);\n    const prefersReduced = typeof window !== 'undefined' && window.matchMedia?.('(prefers-reduced-motion: reduce)').matches;\n    const animationsDisabled = typeof document !== 'undefined' && document.body?.classList.contains('no-animations');\n    if (prefersReduced || animationsDisabled) return; // v tomto režimu necháme jen statický glow\n    let flickerInterval: number | null = null;\n    const host = document.querySelector('#manifest-container .noising-text') as HTMLElement | null;\n    if (!host) return;\n    const run = () => {\n      const arr = host.querySelectorAll('.noising-char');\n      if (!arr || !arr.length) return;\n      const bursts = 1 + Math.floor(Math.random()*3);\n      for (let b=0; b<bursts; b++){\n        const i = Math.floor(Math.random()*arr.length);\n        const el = arr[i] as HTMLElement;\n        if (!el) continue;\n        el.classList.add('flickering');\n        window.setTimeout(() => { try { el.classList.remove('flickering'); } catch {} }, 140 + Math.random()*240);\n      }\n    };\n    flickerInterval = window.setInterval(run, 360 + Math.random()*720) as unknown as number;\n    return () => { if (flickerInterval) { clearInterval(flickerInterval); flickerInterval = null; } try { window.clearTimeout(id); } catch {} };\n  }, [typedDone]);\n\n  // Glitch efekt přepnut do helperu v /public/js/ui-helpers.js pro čistější page.tsx\n  useEffect(() => {\n    const prefersReduced = typeof window !== \"undefined\" && window.matchMedia?.(\"(prefers-reduced-motion: reduce)\").matches;\n    if (prefersReduced) return;\n    let detach: null | (() => void) = null;\n    const root = glitchRootRef.current;\n    if (!root) return;\n    function tryAttach(){\n      if (typeof window !== 'undefined' && typeof (window as any).attachGlitchHeading === 'function'){\n        detach = (window as any).attachGlitchHeading(root, TITLE, { intervalMs: 260, chance: 0.08, restoreMin: 160, restoreJitter: 140 });\n        return true;\n      }\n      return false;\n    }\n    if (!tryAttach()){\n      const maxWait = 2000; const start = Date.now();\n      const id = window.setInterval(() => { if (tryAttach() || Date.now()-start>maxWait) window.clearInterval(id); }, 50);\n    }\n    return () => { if (detach) try { detach(); } catch {} };\n  }, []);\n\n  return (\n    <main className=\"home\" role=\"main\">\n      <section className=\"hero-intro\" aria-label=\"SYNTHOMA Intro\">\n        <div id=\"resizing-text\" className={`intro-title ${showTitle ? \"visible\" : \"\"}`.trim()}>\n          <h1 id=\"glitch-synthoma\" className=\"glitch-master\" ref={glitchRootRef} aria-label={TITLE}>\n            <span className=\"glitch-fake1\">{TITLE}</span>\n            <span className=\"glitch-fake2\">{TITLE}</span>\n            <span className=\"glitch-real\" aria-hidden=\"true\">\n              {TITLE.split(\"\").map((ch, idx) => (\n                <span key={idx} className=\"glitch-char\">{ch}</span>\n              ))}\n            </span>\n            <span className=\"sr-only\">{TITLE}</span>\n          </h1>\n        </div>\n\n        <div className={`manifest-wrapper ${typedDone ? 'has-cta' : ''}`.trim()}>\n          <p className=\"manifest typewriter shinning\" id=\"manifest-container\" aria-live=\"polite\" aria-atomic >\n            <span className=\"noising-text\" aria-hidden=\"true\"></span>\n            <span className=\"sr-only\">{MANIFEST}</span>\n          </p>\n        </div>\n        {typedDone && !showReader ? (\n          <div className=\"hero-cta\">\n            <button\n              className={`glitch-button appear ${btnVisible ? 'visible' : ''}`.trim()}\n              onClick={handleContinue}\n              aria-label={BTN_LABEL}\n              ref={btnGlitchRef}\n              disabled={isAudioPlaying || isStartingAudioRef.current}\n            >\n              <span className=\"glitch-fake1\"></span>\n              <span className=\"glitch-fake2\"></span>\n              <span className=\"glitch-real\" aria-hidden=\"true\">\n                <span className=\"noising-text\"></span>\n              </span>\n              <span className=\"sr-only\">{BTN_LABEL}</span>\n            </button>\n          </div>\n        ) : null}\n\n        {showReader ? (\n          <div className=\"reader-container\" aria-live=\"polite\">\n            <div className=\"SYNTHOMAREADER terminal\" role=\"region\" aria-label=\"Terminál SYNTHOMA\">\n              <div id=\"reader-content\">\n                <div id=\"reader-log\" className=\"log\">\n                  <span className=\"noising-text\"></span>\n                  <span className=\"sr-only\">LOG: [SYSTEM BOOT]</span>\n                </div>\n                {/* Minimal body host kvůli sekvenci typewriteru */}\n                <div id=\"reader-body\" className=\"text\">\n                  <span className=\"noising-text\" aria-hidden=\"true\"></span>\n                </div>\n                <p id=\"reader-dialog\" className=\"dialog\">\n                  <span className=\"noising-text\"></span>\n                  <span className=\"sr-only\">„Vítej v SYNTHOMĚ, <span className=\"glitching\">@&SĐYŁ</span> !!! Tady jméno nikoho nezajímá, ale chyby? Ty jsou v paměti věčně.“</span>\n                </p>\n                <div id=\"reader-title\" className=\"title reader-title\">\n                  <span className=\"noising-text\" aria-hidden=\"true\"></span>\n                  <span className=\"rich-hidden\" aria-hidden=\"true\">\n                    Kam chceš pokračovat??\n                  </span>\n                </div>\n                <div className={`reader-controls appear ${controlsVisible ? 'visible' : ''}`.trim()}>\n                  <button type=\"button\" className=\"glitch-button small\" onClick={handleInfoClick} aria-label=\"Zobrazit INFO\">INFO</button>\n                  <button type=\"button\" className=\"glitch-button small\" onClick={handleBooksClick} aria-label=\"Zobrazit knihovnu\">Knihy</button>\n                </div>\n                {/* Extra output area for dynamic lists (books/chapters) below controls */}\n                <div id=\"reader-extra\" className=\"text\" aria-live=\"polite\">\n                  <span className=\"noising-text\" aria-hidden=\"true\"></span>\n                </div>\n              </div>\n            </div>\n          </div>\n        ) : null}\n      </section>\n    </main>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\app\\run\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_err' is defined but never used.","line":77,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":18}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'enterNode' and 'node'. Either include them or remove the dependency array.","line":87,"column":6,"nodeType":"ArrayExpression","endLine":87,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [enterNode, node]","fix":{"range":[3584,3586],"text":"[enterNode, node]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'applyEffect', 'enterNode', and 'node'. Either include them or remove the dependency array.","line":118,"column":6,"nodeType":"ArrayExpression","endLine":118,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: [applyEffect, enterNode, node, nodeId, theme]","fix":{"range":[4853,4868],"text":"[applyEffect, enterNode, node, nodeId, theme]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useEffect, useMemo, useState, useCallback } from 'react';\nimport { useRunStore } from '@web/stores/runStore';\nimport { NODES } from '@shared/data/nodes';\nimport type { NodeDef, Option, OptionTag } from '@shared/schemas/game';\n\n/** ———————————————————————————————————————————————————————————\n * Defaultní mapování TAGŮ na drobné MBTI posuny (aplikuje se\n * jen když volba NEMÁ explicitní e.type==='mbti').\n * Bias podle motivu přidáme extra (viz níže).\n */\nconst TAG_TO_MBTI: Partial<Record<OptionTag, { axis:'EI'|'NS'|'TF'|'PJ', toward:any, weight:number }>> = {\n  analysis: { axis:'TF', toward:'T', weight:1 },\n  social:   { axis:'EI', toward:'E', weight:1 },\n  symbol:   { axis:'NS', toward:'N', weight:1 },\n  plan:     { axis:'PJ', toward:'J', weight:1 },\n  improv:   { axis:'PJ', toward:'P', weight:1 },\n  empathy:  { axis:'TF', toward:'F', weight:1 },\n  // risk řeší motivy + modaly\n};\n\nfunction optionHasExplicitMBTI(opt: Option) {\n  return opt.effects?.some(e => (e as any).type === 'mbti');\n}\n\nfunction deriveMBTIEffectsFromTags(opt: Option) {\n  if (!opt.tags || !opt.tags.length) return [];\n  return opt.tags\n    .map(t => TAG_TO_MBTI[t as OptionTag])\n    .filter(Boolean)\n    .map(v => ({ type:'mbti', value: v })) as any[];\n}\n\n/** ———————————————————————————————————————————————————————————\n * Teleport: preferuj portálové uzly (tagy začínající 'portal:').\n * Když nejsou, vezmi 'glitch' nebo 'memory_trap', jinak libovolný jiný než aktuální.\n */\nfunction pickTeleportTarget(currentId: string): NodeDef {\n  const portals = NODES.filter(n => n.id !== currentId && (n.tags?.some(t => t.startsWith('portal:'))));\n  const glitchy = NODES.filter(n => n.id !== currentId && (n.tags?.includes('glitch') || n.tags?.includes('memory_trap')));\n  const pool = (portals.length ? portals : (glitchy.length ? glitchy : NODES.filter(n => n.id !== currentId)));\n  return pool[Math.floor(Math.random()*pool.length)];\n}\n\n/** ———————————————————————————————————————————————————————————\n * UI orchestrátor: modal/overlay/delay/toast se řeší v UI,\n * numerika/MBTI jde přes store (kvůli persistu a RT heuristice).\n */\nexport default function RunPage() {\n  const {\n    nodeId, theme, hp, sanity, access,\n    enterNode, choose, applyEffect, setTheme\n  } = useRunStore(s => ({\n    nodeId: s.nodeId, theme: s.theme, hp: s.hp, sanity: s.sanity, access: s.access,\n    enterNode: s.enterNode, choose: s.choose, applyEffect: s.applyEffect, setTheme: s.setTheme\n  }));\n\n  const [overlay, setOverlay] = useState<null | { kind:'loading'|'error', until:number }>(null);\n\n  const node = useMemo(() => NODES.find(n => n.id === nodeId)!, [nodeId]);\n\n  // Po příchodu z úvodu: případně spusť hudbu\n  useEffect(() => {\n    try {\n      if (typeof window === 'undefined') return;\n      const shouldPlay = sessionStorage.getItem('synthoma_play_audio') === '1';\n      if (!shouldPlay) return;\n      sessionStorage.removeItem('synthoma_play_audio');\n      const w = window as any;\n      if (!w.__synthomaAudio) {\n        w.__synthomaAudio = new Audio('/audio/SynthBachmoff.mp3');\n        w.__synthomaAudio.loop = false; // necháme doznít\n        w.__synthomaAudio.volume = 1.0;\n      }\n      w.__synthomaAudio.play?.().catch(() => { /* no-op: autoplay může být blokován */ return; });\n    } catch (_err) { /* ignore audio init errors */ }\n  }, []);\n\n  // Init první běh (pokud by někdo přišel rovnou sem bez state)\n  useEffect(() => {\n    if (!node) {\n      // Fail-safe: pošli do prázdnoty\n      enterNode('void-boot');\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // onEnter pipeline: spustit efekty uzlu + acid teleport 5 %\n  useEffect(() => {\n    if (!node) return;\n\n    // UI: spustit onEnter „lehká“ upozornění (overlay/toast), numeriku necháme na store.applyEffect\n    (node.onEnter || []).forEach(e => {\n      if ((e as any).type === 'overlay') {\n        const ms = (e as any).ms ?? 250;\n        setOverlay({ kind: (e as any).value, until: performance.now() + ms });\n        setTimeout(() => setOverlay(null), ms);\n      }\n      if ((e as any).type === 'toast') {\n        (window as any).toast?.((e as any).message, (e as any).value, 2400);\n      }\n      // numerika: poslat do store\n      if (['hp','sanity','access','theme','mbti'].includes((e as any).type)) {\n        applyEffect(e, `onEnter:${node.id}`);\n      }\n    });\n\n    // Acid-glitch teleport: 5 % šance po vstupu\n    if (theme === 'acid-glitch' && Math.random() < 0.05) {\n      (window as any).toast?.('Mapa přepisuje okraje…', 'info', 2400);\n      const next = pickTeleportTarget(node.id);\n      // drobný N bias za „symbolickou“ odchylku\n      applyEffect({ type:'mbti', value:{ axis:'NS', toward:'N', weight:0.5 }}, 'acid-teleport');\n      setTimeout(() => enterNode(next.id), 260);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [nodeId, theme]);\n\n  const handleThemeSwitch = useCallback((t: any) => {\n    setTheme(t);\n    // MBTI drobek za rituál motivu (UI vrstvě patří bias)\n    const bias: Record<string, any> = {\n      'green-matrix': { axis:'TF', toward:'T', weight:1 },\n      'neon-hellfire': { axis:'PJ', toward:'P', weight:1 },\n      'cyber-dystopia': { axis:'PJ', toward:'J', weight:1 },\n      'acid-glitch': { axis:'NS', toward:'N', weight:1 },\n      'retro-arcade': { axis:'EI', toward:'E', weight:1 },\n    };\n    if (bias[t]) applyEffect({ type:'mbti', value: bias[t] }, 'ritual:theme');\n    (window as any).toast?.(`Rituál: ${t} aktivní.`, 'info', 1800);\n  }, [applyEffect, setTheme]);\n\n  // Volba: modal confirm (risk, nebo cyber-dystopia implicitně na risk tagu),\n  // RT se měří uvnitř store.choose(), tak UI efekty řešíme až po něm.\n  const onChoose = useCallback(async (opt: Option) => {\n    const hasModal = opt.effects?.some(e => (e as any).type === 'modal');\n    const isRiskTag = opt.tags?.includes('risk');\n    const needConfirm = !!hasModal || (theme === 'cyber-dystopia' && isRiskTag);\n\n    if (needConfirm) {\n      const ok = await ((window as any).confirmRisk?.('Tahle akce může rozleptat realitu. Pokračovat?') ?? Promise.resolve(confirm('Tahle akce může rozleptat realitu. Pokračovat?')));\n      if (!ok) {\n        (window as any).toast?.('Akce zrušena. Systém si to zapíše.', 'warning', 2000);\n        return;\n      }\n      // Drobné MBTI biasy za potvrzení rizika podle motivu\n      if (theme === 'cyber-dystopia') applyEffect({ type:'mbti', value:{ axis:'PJ', toward:'J', weight:0.5 }}, 'confirm:dystopia');\n      if (theme === 'neon-hellfire') applyEffect({ type:'mbti', value:{ axis:'PJ', toward:'P', weight:0.5 }}, 'confirm:hellfire');\n    }\n\n    // Necháme store.choose spočítat RT a aplikovat numeriku a explicitní MBTI\n    choose(opt);\n\n    // UI efekty z opt.effects: overlay/delay/toast (bez numeriky, tu udělal store)\n    for (const e of (opt.effects || [])) {\n      if ((e as any).type === 'overlay') {\n        const ms = (e as any).ms ?? 250;\n        setOverlay({ kind: (e as any).value, until: performance.now() + ms });\n        await new Promise(r => setTimeout(r, ms));\n        setOverlay(null);\n      }\n      if ((e as any).type === 'delay') {\n        await new Promise(r => setTimeout(r, (e as any).ms));\n      }\n      if ((e as any).type === 'toast') {\n        (window as any).toast?.((e as any).message, (e as any).value, 2400);\n      }\n    }\n\n    // Pokud volba neměla explicitní MBTI, aplikuj default z TAGŮ\n    if (!optionHasExplicitMBTI(opt)) {\n      const derived = deriveMBTIEffectsFromTags(opt);\n      derived.forEach(d => applyEffect(d, `tags:${(opt.tags||[]).join(',')}`));\n    }\n\n    // Přechod do dalšího uzlu\n    enterNode(opt.nextId);\n  }, [choose, applyEffect, enterNode, theme]);\n\n  // Render\n  return (\n    <main className=\"p-16\">\n      {/* Horní bar: staty */}\n      <div className=\"panel fx-noise p-8-12 mb-12 flex gap-16 items-baseline\">\n        <span>HP: <b>{hp}</b></span>\n        <span>Sanity: <b>{sanity}</b></span>\n        <span>Access: <b>{access}</b></span>\n        <span className=\"ml-auto opacity-75\">Motiv:</span>\n        <div className=\"flex gap-6\">\n          {(['synthoma','green-matrix','neon-hellfire','cyber-dystopia','acid-glitch','retro-arcade'] as const).map(t => (\n            <button key={t}\n              className=\"btn fx-glitch btn-sm\"\n              data-glitch=\"soft\"\n              data-text={t}\n              onClick={()=>handleThemeSwitch(t)}\n              aria-pressed={theme === t ? 'true' : 'false'}\n            >\n              {t}\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Uzel */}\n      <section className=\"panel fx-noise p-16\">\n        <h1 className=\"glitch-title scramble-title\" data-glitch={node.unstable ? 'on' : 'soft'}>\n          <span className=\"scramble-base\">{node.title}</span>\n          <span className=\"scramble-layer\" data-target={node.title} aria-hidden=\"true\"></span>\n          <span className=\"sr-only\">{node.title}</span>\n        </h1>\n        <p className=\"opacity-90 mt-8\">{node.text}</p>\n\n        {/* Volby */}\n        <div className=\"grid gap-8 mt-12\">\n          {node.options.map(opt => (\n            <div key={opt.id} className=\"grid gap-6\">\n              <button\n                className=\"btn fx-glitch btn-lg text-left\"\n                data-glitch=\"soft\"\n                data-text={opt.label}\n                onClick={()=>onChoose(opt)}\n                aria-describedby={opt.hint ? `hint-${opt.id}` : undefined}\n              >\n                {opt.label}\n              </button>\n              {opt.hint ? (\n                <small id={`hint-${opt.id}`} className=\"text-muted opacity-70\">\n                  {opt.hint}\n                </small>\n              ) : null}\n            </div>\n          ))}\n        </div>\n      </section>\n\n      {/* Overlay stavy */}\n      {overlay ? (\n        <div\n          aria-live=\"polite\"\n          className=\"modal overlay-center bg-overlay\"\n        >\n          <div className=\"panel p-12 rounded-12\">\n            {overlay.kind === 'loading' ? 'Hackuješ…' : 'Chyba ve vrstvě reality…'}\n          </div>\n        </div>\n      ) : null}\n    </main>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\next-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\client\\ControlPanelClient.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\client\\UiHelpersClient.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\client\\VideoVisualsClient.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\components\\GlitchScrambleTitle.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":86,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":86,"endColumn":60}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\nimport { useEffect, useRef, useCallback } from \"react\";\n\nconst GLYPHS = \"█▓▒░/\\\\|_-=+*<>[](){}#?¡!¿@%&$§æÆøØß†‡ΔΣΛΨΩµ≠≈±«»^~·•\";\n\nexport function GlitchScrambleTitle({\n  as = \"h1\",\n  children,\n  intensity = 0.35,\n  burstMs = 260,\n  minPause = 1100,\n  maxPause = 2400,\n  loop = true,\n  className = \"\",\n  ...rest\n}: {\n  as?: keyof JSX.IntrinsicElements;\n  children: string;\n  intensity?: number;\n  burstMs?: number;\n  minPause?: number;\n  maxPause?: number;\n  loop?: boolean;\n  className?: string;\n  [key: string]: any;\n}) {\n  const Tag = as as any;\n  const prefersReduced =\n    typeof window !== \"undefined\" && window.matchMedia?.(\"(prefers-reduced-motion: reduce)\").matches;\n  const animationsDisabled = typeof document !== \"undefined\" && document.body?.classList.contains(\"no-animations\");\n  const rootRef = useRef<HTMLElement | null>(null);\n  const layerRef = useRef<HTMLSpanElement | null>(null);\n  const baseRef = useRef<HTMLSpanElement | null>(null);\n  const rafRef = useRef<number | null>(null);\n  const timerRef = useRef<number | null>(null);\n\n  const setText = (t: string) => {\n    if (!layerRef.current || !baseRef.current) return;\n    layerRef.current.dataset.target = t;\n    baseRef.current.textContent = t;\n    layerRef.current.textContent = t;\n  };\n\n  useEffect(() => {\n    setText(children);\n  }, [children]);\n\n  function randomGlyph() {\n    return GLYPHS[Math.floor(Math.random() * GLYPHS.length)];\n  }\n\n  const scrambleOnce = useCallback((dur = burstMs) => {\n    const layer = layerRef.current!;\n    const target = (layer.dataset.target || \"\").toString();\n    const original = target.split(\"\");\n    const len = original.length;\n    const now = performance.now();\n\n    const schedule = new Array(len).fill(0).map((_, i) => {\n      const active = original[i] !== \" \" && Math.random() < intensity;\n      const start = now + Math.random() * (dur * 0.35);\n      const end = start + dur * (0.35 + Math.random() * 0.65);\n      return { active, start, end };\n    });\n\n    const step = (t: number) => {\n      let allDone = true;\n      const out = original.map((ch, i) => {\n        const s = schedule[i];\n        if (!s.active || ch === \" \") return ch;\n        if (t < s.start) {\n          allDone = false;\n          return ch;\n        }\n        if (t >= s.end) {\n          return ch;\n        }\n        allDone = false;\n        return randomGlyph();\n      });\n      layer.textContent = out.join(\"\");\n      if (!allDone) rafRef.current = requestAnimationFrame(step);\n      else layer.textContent = target;\n    };\n\n    rafRef.current && cancelAnimationFrame(rafRef.current);\n    rafRef.current = requestAnimationFrame(step);\n  }, [burstMs, intensity]);\n\n  useEffect(() => {\n    if (prefersReduced || animationsDisabled || !loop) return;\n    const loopPulse = () => {\n      scrambleOnce();\n      const pause = minPause + Math.random() * (maxPause - minPause);\n      // setTimeout vrací number v browseru\n      timerRef.current = window.setTimeout(loopPulse, pause) as unknown as number;\n    };\n    loopPulse();\n    return () => {\n      if (timerRef.current) clearTimeout(timerRef.current);\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    };\n  }, [intensity, burstMs, minPause, maxPause, loop, prefersReduced, animationsDisabled, scrambleOnce]);\n\n  useEffect(() => {\n    const root = rootRef.current!;\n    const onEnter = () => !prefersReduced && !animationsDisabled && scrambleOnce();\n    root.addEventListener(\"pointerenter\", onEnter);\n    return () => root.removeEventListener(\"pointerenter\", onEnter);\n  }, [prefersReduced, animationsDisabled, scrambleOnce]);\n\n  return (\n    <Tag className={`glitch-title scramble-title ${className}`.trim()} data-glitch=\"on\" ref={rootRef as any} {...rest}>\n      <span className=\"scramble-base\" ref={baseRef}>{children}</span>\n      <span className=\"scramble-layer\" ref={layerRef} data-target={children} aria-hidden=\"true\"></span>\n      <span className=\"sr-only\">{children}</span>\n    </Tag>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\lib\\audio.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\lib\\cinematicButton.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":72,"column":15,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":72,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":73,"column":15,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":73,"endColumn":78}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type CancelFn = () => void;\n\n/**\n * Scripted cinematic intro for the CTA button. Similar sweep + reveal as the title,\n * but DOES NOT enable infinite glitch; hover CSS handles glitches.\n */\nexport function runCinematicButtonIntro(root: HTMLElement): CancelFn {\n  const prefersReduced = typeof window !== 'undefined' && window.matchMedia?.('(prefers-reduced-motion: reduce)').matches;\n  const real = root.querySelector('.glitch-real') as HTMLElement | null;\n  const chars = Array.from(root.querySelectorAll('.glitch-char')) as HTMLElement[];\n\n  const timers: number[] = [];\n  const set = (fn: () => void, ms: number) => { const id = window.setTimeout(fn, ms) as unknown as number; timers.push(id); return id; };\n  const clearAll = () => { while (timers.length) { const id = timers.pop(); if (typeof id === 'number') try { clearTimeout(id); } catch {} } };\n\n  try {\n    root.style.opacity = '0';\n    root.style.transform = 'translateY(10px) scale(0.97)';\n    root.style.filter = 'brightness(0.85) saturate(0.9)';\n    (root as HTMLElement).style.animation = 'none';\n    if (real) (real as HTMLElement).style.willChange = 'opacity, filter, clip-path, transform';\n    chars.forEach(ch => { ch.style.opacity = '0'; ch.style.transition = 'opacity 220ms ease, filter 220ms ease'; });\n  } catch {}\n\n  if (!prefersReduced) {\n    set(() => { try { root.style.transition = 'opacity 700ms ease, transform 900ms cubic-bezier(.2,.9,.1,1), filter 900ms ease'; } catch {} }, 10);\n    set(() => { try { root.style.opacity = '0.18'; root.style.transform = 'translateY(4px) scale(0.985)'; root.style.filter = 'brightness(0.98) saturate(1.04)'; } catch {} }, 40);\n    set(() => { try { root.style.opacity = '0.5'; root.style.transform = 'translateY(2px) scale(0.995)'; root.style.filter = 'brightness(1.05) saturate(1.1)'; } catch {} }, 420);\n\n    const startT = performance.now() + 1000;\n    const sweepDur = 1400;\n    const totalChars = Math.max(1, chars.length);\n    const sweep = () => {\n      const now = performance.now();\n      const t = Math.min(1, Math.max(0, (now - startT) / sweepDur));\n      try { if (real) (real as HTMLElement).style.clipPath = `inset(0 ${100 - t*100}% 0 0)`; } catch {}\n      const upto = Math.floor(t * totalChars);\n      for (const el of chars.slice(0, upto)) {\n        if (el && el.style.opacity !== '1') {\n          el.style.opacity = '1';\n          el.style.filter = 'brightness(1.08)';\n          set(() => { try { el.style.filter = ''; } catch {} }, 140);\n        }\n      }\n      if (t < 1) set(sweep, 16);\n    };\n    set(sweep, 1020);\n\n    set(() => { try { root.style.filter = 'brightness(1.2) saturate(1.25)'; } catch {} }, 2700);\n    set(() => { try { root.style.filter = 'brightness(1.0) saturate(1.15)'; } catch {} }, 2900);\n    set(() => { try { root.style.filter = 'var(--filter-primary)'; root.style.transform = 'none'; } catch {} }, 3200);\n    // end: keep hover-only glitch; only reset clipPath\n    set(() => { try { if (real) (real as HTMLElement).style.clipPath = ''; } catch {} }, 3400);\n    // enable shining/noising on button characters after intro settles\n    set(() => {\n      try {\n        const animationsDisabled = typeof document !== 'undefined' && document.body?.classList.contains('no-animations');\n        chars.forEach(ch => {\n          const isVisible = (ch.textContent || '').trim().length > 0;\n          ch.classList.remove('noising-burst','flickering');\n          if (!isVisible) return;\n          ch.classList.add('noising-char');\n          if (!prefersReduced && !animationsDisabled) {\n            ch.classList.add('noising');\n            ch.classList.add('noising-burst');\n            window.setTimeout(() => { try { ch.classList.remove('noising-burst'); } catch {} }, 220);\n          } else {\n            ch.classList.remove('noising');\n            ch.classList.add('noising-static');\n          }\n        });\n        try { (window as any).startShinning && (window as any).startShinning(); } catch {}\n        try { (window as any).startNoising && (window as any).startNoising(); } catch {}\n      } catch {}\n    }, 3600);\n  } else {\n    set(() => { try { root.style.transition = 'opacity 600ms ease, transform 600ms ease'; root.style.opacity = '1'; root.style.transform = 'none'; } catch {} }, 30);\n    // reduced motion: still mark static shining/noising immediately\n    set(() => {\n      try {\n        chars.forEach(ch => {\n          const isVisible = (ch.textContent || '').trim().length > 0;\n          if (!isVisible) return;\n          ch.classList.add('noising-char','noising-static');\n          ch.classList.remove('noising');\n        });\n      } catch {}\n    }, 80);\n  }\n\n  return () => {\n    clearAll();\n    try {\n      root.style.transition = '';\n      root.style.transform = '';\n      root.style.filter = '';\n      (root as HTMLElement).style.animation = '';\n      if (real) (real as HTMLElement).style.clipPath = '';\n      chars.forEach(ch => {\n        ch.style.opacity = '';\n        ch.style.transition = '';\n        ch.classList.remove('noising','noising-burst','noising-static');\n        // keep noising-char marker optional; remove if you want a pristine detach\n        // ch.classList.remove('noising-char');\n      });\n    } catch {}\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\lib\\cinematicTitle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\lib\\typewriter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":372,"column":9,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":372,"endColumn":74},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":462,"column":13,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":462,"endColumn":78},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":463,"column":13,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":463,"endColumn":76}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type CancelFn = () => void;\n\ninterface TypewriterOptions {\n  text: string;\n  host: HTMLElement; // container that has a span.noising-text inside\n  getDurationMs?: () => number; // returns the total typing duration from CSS variables\n  onStart?: () => void;\n  onDone?: () => void;\n}\n\n// --- Kapitoly: injektuj <style>/<link> z HTML kapitoly do <head> a vrať obsah <body> ---\nfunction absolutizeUrl(raw: string, baseUrl: string): string {\n  const url = raw.trim().replace(/^['\"]|['\"]$/g, '');\n  if (!url) return url;\n  if (/^(?:[a-z]+:)?\\/\\//i.test(url)) return url; // http(s): or protocol-relative\n  if (/^(?:data:|blob:|about:)/i.test(url)) return url;\n  if (url.startsWith('/')) return url; // already root-based\n  return baseUrl.replace(/\\/[^/]*$/, '/') + url; // ensure trailing slash then append\n}\n\nfunction rewriteCssUrls(cssText: string, baseUrl: string): string {\n  return cssText.replace(/url\\(([^)]+)\\)/gi, (m, p1) => {\n    const abs = absolutizeUrl(String(p1), baseUrl);\n    return `url(${abs})`;\n  }).replace(/@import\\s+url\\(([^)]+)\\)/gi, (m, p1) => {\n    const abs = absolutizeUrl(String(p1), baseUrl);\n    return `@import url(${abs})`;\n  }).replace(/@import\\s+['\"]([^'\\\"]+)['\"]/gi, (m, p1) => {\n    const abs = absolutizeUrl(String(p1), baseUrl);\n    return `@import url(${abs})`;\n  });\n}\n\nfunction clearPreviousChapterAssets(): void {\n  const head = document.head;\n  const nodes = Array.from(head.querySelectorAll('[data-chapter-asset=\"1\"]')) as HTMLElement[];\n  nodes.forEach(n => { try { n.remove(); } catch {} });\n}\n\nfunction installChapterAssetsAndGetBody(html: string, baseUrl: string, _key: string): string {\n  try {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, 'text/html');\n    const head = document.head;\n    // Vyčisti předchozí injekce\n    clearPreviousChapterAssets();\n\n    // <link rel=\"stylesheet\"/preload font>\n    const links = Array.from(doc.querySelectorAll('link')) as HTMLLinkElement[];\n    for (const l of links) {\n      const rel = (l.getAttribute('rel') || '').toLowerCase();\n      if (!rel) continue;\n      if (rel === 'stylesheet' || (rel === 'preload' && (l.getAttribute('as') || '').toLowerCase() === 'font') || rel === 'preconnect') {\n        const el = document.createElement('link');\n        el.rel = l.rel;\n        const href = l.getAttribute('href') || '';\n        if (href) el.href = absolutizeUrl(href, baseUrl);\n        const asv = l.getAttribute('as'); if (asv) el.as = asv as any;\n        const cross = l.getAttribute('crossorigin'); if (cross) el.setAttribute('crossorigin', cross);\n        const media = l.getAttribute('media'); if (media) el.media = media;\n        el.setAttribute('data-chapter-asset', '1');\n        head.appendChild(el);\n      }\n    }\n\n    // <style> bloky (z headu i body)\n    const styles = Array.from(doc.querySelectorAll('style')) as HTMLStyleElement[];\n    for (const s of styles) {\n      const el = document.createElement('style');\n      el.type = s.type || 'text/css';\n      el.textContent = rewriteCssUrls(s.textContent || '', baseUrl);\n      el.setAttribute('data-chapter-asset', '1');\n      head.appendChild(el);\n    }\n\n    // Přepiš relativní URL v body (img/src, video/audio/source/src, a[href] na kapitolu)\n    const body = doc.body;\n    if (body) {\n      const rewriteAttr = (el: Element, attr: string) => {\n        const val = el.getAttribute(attr);\n        if (!val) return;\n        el.setAttribute(attr, absolutizeUrl(val, baseUrl));\n      };\n      body.querySelectorAll('img, video, audio, source, track').forEach((el) => rewriteAttr(el as Element, 'src'));\n      body.querySelectorAll('a[href]').forEach((el) => {\n        const href = el.getAttribute('href') || '';\n        // ponech #anchor a absolutní odkazy\n        if (href.startsWith('#') || /^(?:[a-z]+:)?\\/\\//i.test(href)) return;\n        (el as Element).setAttribute('href', absolutizeUrl(href, baseUrl));\n      });\n      return body.innerHTML;\n    }\n    return html;\n  } catch (e) {\n    console.warn('chapter assets install failed', e);\n    return html;\n  }\n}\n\n// --- Externí utilitky pro typewriter na #reader-body ---\n\nfunction extractTextFromRichHost(host: HTMLElement): string {\n  const rich = host.querySelector('.rich-hidden') as HTMLElement | null;\n  const normalize = (raw: string) => raw\n    .replace(/&nbsp;|&#160;/gi, ' ')\n    .replace(/\\r\\n?/g, '\\n');\n  if (rich) {\n    const rawHtml = rich.innerHTML || '';\n    const html2 = normalize(rawHtml);\n    let text = html2\n      .replace(/<br\\s*\\/?>(?=\\s*\\n?)/gi, '\\n')\n      .replace(/<\\/(p|div|h[1-6]|li)>/gi, '</$1>\\n')\n      .replace(/<li[^>]*>/gi, '• ')\n      .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n      .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n      .replace(/<[^>]+>/g, '')\n      .replace(/[\\t ]+\\n/g, '\\n')\n      .replace(/\\n{3,}/g, '\\n\\n')\n      .trim();\n    if (!text) text = normalize(rich.textContent || '').trim();\n    return text;\n  }\n  return '';\n}\n\nexport async function startBodyTypingFromHtml(html: string, hostSelector = '#reader-body'): Promise<void> {\n  const bodyHost = document.querySelector(hostSelector) as HTMLElement | null;\n  if (!bodyHost) { console.log('typewriter: no bodyHost'); return; }\n  const ds = (bodyHost as any).dataset as Record<string, string | undefined>;\n  if (ds.twBusy === '1') { console.log('typewriter: external busy, skipping'); return; }\n  ds.twBusy = '1';\n\n  // vlož/nahraď externí rich obsah\n  let ext = bodyHost.querySelector('.rich-external') as HTMLElement | null;\n  if (!ext) {\n    ext = document.createElement('div');\n    ext.className = 'rich-hidden rich-external';\n    (ext.style as any).display = 'none';\n    bodyHost.appendChild(ext);\n  }\n  ext.innerHTML = html || '';\n\n  // připrav zobrazovací kontejner\n  let container = bodyHost.querySelector('.noising-text') as HTMLElement | null;\n  if (!container) {\n    container = document.createElement('span');\n    container.className = 'noising-text';\n    bodyHost.appendChild(container);\n  } else {\n    container.textContent = '';\n  }\n  (container.style as any).whiteSpace = 'pre-wrap';\n  (container.style as any).display = 'block';\n\n  const fullText = extractTextFromRichHost(bodyHost);\n  console.log('typewriter: external fullText', { len: fullText.length, sample: fullText.slice(0, 120) });\n  let lines = fullText.split(/\\n/);\n  if (lines.length <= 1 && fullText.length > 300) {\n    lines = fullText.split(/\\n|(?<=[\\.?!…])\\s+(?=[A-ZÁ-Ž0-9„(])/u);\n  }\n  const lengths = lines.map(l => l.length || 1);\n  const totalChars = lengths.reduce((a,b)=>a+b,0) || 1;\n  const computeTotalDuration = () => {\n    const mw = document.getElementById('manifest-container');\n    if (mw) {\n      const cs = getComputedStyle(mw);\n      const durVar = cs.getPropertyValue('--typewriter-duration').trim();\n      if (durVar.endsWith('ms')) return parseFloat(durVar) * 3.5;\n      if (durVar.endsWith('s')) return parseFloat(durVar) * 1000 * 3.5;\n    }\n    return 24000;\n  };\n  const totalDuration = computeTotalDuration();\n\n  const scrollTerminalBottom = () => {\n    try { window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' }); } catch {}\n  };\n\n  const startLine = (idx: number, onAllDone: () => void) => {\n    if (idx >= lines.length) { onAllDone(); return; }\n    const text = lines[idx];\n    const lineEl = document.createElement('span');\n    (lineEl.style as any).whiteSpace = 'pre-wrap';\n    (lineEl.style as any).display = 'block';\n    // runTypewriter očekává uvnitř hosta element .noising-text\n    const inner = document.createElement('span');\n    inner.className = 'noising-text';\n    lineEl.appendChild(inner);\n    container!.appendChild(lineEl);\n    scrollTerminalBottom();\n    const share = lengths[idx] / totalChars;\n    let dur = Math.max(250, Math.round(totalDuration * share));\n    const perChar = Math.min(5000, Math.max(250, (text.length || 1) * 22));\n    dur = Math.min(dur, perChar);\n    if (!text || text.trim() === '') {\n      window.setTimeout(() => startLine(idx + 1, onAllDone), 10);\n      return;\n    }\n    const cancel = runTypewriter({\n      text,\n      host: lineEl,\n      getDurationMs: () => dur,\n      onStart: () => { /* noop */ return; },\n      onDone: () => { scrollTerminalBottom(); startLine(idx + 1, onAllDone); }\n    });\n    void cancel;\n  };\n\n  console.log('typewriter: external start', { lines: lines.length });\n  startLine(0, () => {\n    console.log('typewriter: external done');\n    try { ds.twBusy = '0'; } catch {}\n    // Swap na bohaté HTML + inicializace glitch pro nové prvky\n    try {\n      const rich = bodyHost.querySelector('.rich-hidden') as HTMLElement | null;\n      if (rich) {\n        bodyHost.innerHTML = rich.innerHTML;\n        const nodes = bodyHost.querySelectorAll('.glitch-master, .glitching');\n        const toInit: HTMLElement[] = [];\n        nodes.forEach((el) => {\n          const d = (el as HTMLElement).dataset as any;\n          if (!d || !d.glitchInit) {\n            (el as HTMLElement).classList.add('glitch-to-init');\n            if (d) d.glitchInit = '1';\n            toInit.push(el as HTMLElement);\n          }\n        });\n        const sg = (window as any).startGlitching;\n        if (toInit.length && typeof sg === 'function') {\n          sg('.glitch-to-init');\n          toInit.forEach((el) => el.classList.remove('glitch-to-init'));\n        }\n      }\n    } catch {}\n  });\n}\n\nexport async function typeExternalInfo(): Promise<void> {\n  const url = '/data/SYNTHOMAINFO.html';\n  const res = await fetch(url, { cache: 'no-store' });\n  const html = await res.text();\n  const baseUrl = '/data/';\n  const bodyHtml = installChapterAssetsAndGetBody(html, baseUrl, 'info');\n  await startBodyTypingFromHtml(bodyHtml);\n}\n\nfunction setupBooksHandlers() {\n  const container = document.querySelector('#reader-content') as HTMLElement | null;\n  if (!container) return;\n  const d = (container as any).dataset as Record<string, string|undefined>;\n  if (d.booksHandlers) return;\n  d.booksHandlers = '1';\n  container.addEventListener('click', (ev) => {\n    const target = ev.target as HTMLElement | null;\n    if (!target) return;\n    const a = target.closest('a') as HTMLAnchorElement | null;\n    if (!a) return;\n    if (a.classList.contains('book-link')) {\n      ev.preventDefault();\n      const book = a.getAttribute('data-book') || '';\n      if (book) { typeBooksList(book).catch(() => { /* ignore */ }); }\n    } else if (a.classList.contains('chapter-link')) {\n      ev.preventDefault();\n      const book = a.getAttribute('data-book') || '';\n      const file = a.getAttribute('data-file') || '';\n      if (book && file) { loadChapter(book, file).catch(() => { /* ignore */ }); }\n    }\n  }, true);\n}\n\nasync function loadChapter(book: string, file: string): Promise<void> {\n  const url = `/books/${encodeURIComponent(book)}/${encodeURIComponent(file)}`;\n  const baseUrl = `/books/${encodeURIComponent(book)}/`;\n  const res = await fetch(url, { cache: 'no-store' });\n  if (!res.ok) throw new Error(`HTTP ${res.status}`);\n  const html = await res.text();\n\n  // Nainstaluj CSS/font assety z kapitoly do <head> a vrať čisté body HTML\n  const key = `chapter:${book}/${file}`;\n  const bodyHtml = installChapterAssetsAndGetBody(html, baseUrl, key);\n  await startBodyTypingFromHtml(bodyHtml, '#reader-extra');\n}\n\nexport async function typeBooksList(book?: string): Promise<void> {\n  // reentrancy guard: pokud externí typewriter běží, nezkoušej spouštět další\n  const bodyHost = document.querySelector('#reader-extra') as HTMLElement | null || document.querySelector('#reader-body') as HTMLElement | null;\n  if (bodyHost) {\n    const ds = (bodyHost as any).dataset as Record<string, string | undefined>;\n    if (ds.twBusy === '1') { console.log('typewriter: books ignored, external busy'); return; }\n  }\n  if (!book) {\n    const res = await fetch('/api/books', { cache: 'no-store' });\n    const data = await res.json();\n    if (!data?.ok) throw new Error(data?.error || 'Unknown');\n    const items = (data.items as {name:string,type:'dir'|'file',size:number}[]);\n    const books = items.filter(it => it.type === 'dir');\n    const list = books.map(it => `<div>📖 <a href=\"#\" class=\"book-link\" data-book=\"${it.name}\">${it.name}</a></div>`).join('');\n    const html = `\n      <h3>Knihovna</h3>\n      <div class=\"books-list\">\n        ${list || '<em>Žádné knihy</em>'}\n      </div>\n    `;\n    await startBodyTypingFromHtml(html, '#reader-extra');\n    setupBooksHandlers();\n    return;\n  }\n\n  // List chapters for selected book\n  const res = await fetch(`/api/books?book=${encodeURIComponent(book)}`, { cache: 'no-store' });\n  const data = await res.json();\n  if (!data?.ok) throw new Error(data?.error || 'Unknown');\n  const items = (data.items as {name:string,type:'dir'|'file',size:number}[]);\n  const chapters = items.filter(it => it.type === 'file' && /\\.html?$/i.test(it.name));\n  const chapterList = chapters.map(it => {\n    const title = it.name.replace(/\\.(html?)$/i, '')\n      .replace(/[_-]+/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .trim();\n    return `<div>🗂️ <a href=\"#\" class=\"chapter-link\" data-book=\"${book}\" data-file=\"${it.name}\">${title}</a></div>`;\n  }).join('');\n  const back = `<div style=\"margin:.5rem 0 1rem\"><a href=\"#\" class=\"book-link\" data-book=\"\">← Zpět na knihy</a></div>`;\n  const html = `\n    <h3>Kniha: ${book}</h3>\n    ${back}\n    <div class=\"books-list\">${chapterList || '<em>Žádné kapitoly</em>'}</div>\n  `;\n  await startBodyTypingFromHtml(html, '#reader-extra');\n  setupBooksHandlers();\n}\n\n/**\n * Runs the char-by-char typewriter with glitchy searcher and integrates with shining/noising helpers on window.\n * Mirrors the previous implementation from page.tsx but packaged for reuse.\n */\nexport function runTypewriter(opts: TypewriterOptions): CancelFn {\n  const { text, host, getDurationMs, onStart, onDone } = opts;\n  const prefersReduced = typeof window !== 'undefined' && window.matchMedia?.('(prefers-reduced-motion: reduce)').matches;\n  const animationsDisabled = typeof document !== 'undefined' && document.body?.classList.contains('no-animations');\n  const span = host.querySelector('.noising-text') as HTMLElement | null;\n  if (!span) return () => { /* noop */ return; };\n\n  const pending: number[] = [];\n  let typingId: number | null = null;\n\n  const clearAll = () => {\n    if (typingId) { try { clearTimeout(typingId); } catch {} typingId = null; }\n    while (pending.length) { const id = pending.pop(); if (typeof id === 'number') try { clearTimeout(id); } catch {} }\n  };\n\n  // If animations are off, render immediately\n  if (prefersReduced || animationsDisabled) {\n    if (onStart) try { onStart(); } catch {}\n    span.textContent = '';\n    const chars = text.split('');\n    for (const ch of chars) {\n      const el = document.createElement('span');\n      el.className = 'tw-char noising-char';\n      el.textContent = ch;\n      if (ch.trim().length > 0) el.classList.add('noising-static');\n      span.appendChild(el);\n    }\n    if (onDone) try { onDone(); } catch {}\n    return clearAll;\n  }\n\n  // Normal animated flow\n  if (onStart) try { onStart(); } catch {}\n  span.textContent = '';\n  const tokens = text.split('');\n  // start shining engine so it can adopt settled chars\n  try { (window as any).startShinning && (window as any).startShinning(); } catch {}\n\n  let totalMs = 7200;\n  try {\n    if (getDurationMs) totalMs = Math.max(100, getDurationMs());\n  } catch {}\n  const perStep = Math.max(12, Math.round(totalMs / Math.max(1, tokens.length)));\n  const GLITCH_CHARS = \"!@#$%^&*_-+=?/|<>[]{};:~NYHSMT#¤%&@§÷×¤░▒▓█▄▀●◊O|/_^-~.*+\";\n\n  let idx = 0;\n  const tick = () => {\n    if (!span) return;\n    const ch = tokens[idx++] || '';\n    const node = document.createElement('span');\n    node.className = 'tw-char';\n\n    if (ch.trim().length > 0) {\n      const rand0 = GLITCH_CHARS[(Math.random() * GLITCH_CHARS.length) | 0] || ch;\n      node.textContent = rand0;\n      const frame = Math.max(18, Math.min(48, Math.round(perStep / 3)));\n      const steps = Math.max(2, Math.min(5, Math.round(perStep / frame)));\n      for (let s = 0; s < steps; s++) {\n        const id = window.setTimeout(() => {\n          if (!node) return;\n          const r = GLITCH_CHARS[(Math.random() * GLITCH_CHARS.length) | 0] || ch;\n          node.textContent = r;\n        }, s * frame) as unknown as number;\n        pending.push(id);\n      }\n      const finalId = window.setTimeout(() => {\n        if (!node) return;\n        node.textContent = ch;\n        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n        const animationsDisabled = document.body && document.body.classList.contains('no-animations');\n        if (!prefersReduced && !animationsDisabled) {\n          node.classList.add('noising-char');\n          node.classList.add('noising');\n          try { node.classList.add('noising-burst'); window.setTimeout(() => { try { node.classList.remove('noising-burst'); } catch {} }, 200); } catch {}\n        }\n      }, steps * frame) as unknown as number;\n      pending.push(finalId);\n    } else {\n      node.textContent = ch;\n    }\n\n    if (ch.trim().length > 0) {\n      node.classList.add('tw-glitch');\n      window.setTimeout(() => { node.classList.remove('tw-glitch'); }, Math.max(80, Math.min(180, Math.round(perStep*0.9))));\n    }\n    span.appendChild(node);\n    if (ch.trim().length > 0 && Math.random() < 0.10) {\n      node.classList.add('tw-split');\n      window.setTimeout(() => { node.classList.remove('tw-split'); }, 120);\n    }\n    if (Math.random() < 0.06) {\n      span.classList.add('tw-blip');\n      window.setTimeout(() => { span.classList.remove('tw-blip'); }, 120);\n    }\n\n    if (idx < tokens.length) {\n      typingId = window.setTimeout(tick, perStep) as unknown as number;\n    } else {\n      try { span.classList.remove('tw-blip'); } catch {}\n      while (pending.length) { const id = pending.pop(); if (typeof id === 'number') try { clearTimeout(id); } catch {} }\n      try {\n        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n        const animationsDisabled = document.body && document.body.classList.contains('no-animations');\n        const chars = text.split('');\n        let nodes = Array.from(span.querySelectorAll('.tw-char')) as HTMLElement[];\n        for (let i=0;i<chars.length;i++){\n          const ch = chars[i] || '';\n          let el = nodes[i];\n          if (!el){ el = document.createElement('span'); el.className = 'tw-char'; span.appendChild(el); }\n          el.textContent = ch;\n          el.classList.remove('tw-glitch','tw-split','flickering');\n          if (!prefersReduced && !animationsDisabled && ch.trim().length>0) {\n            el.classList.add('noising-char','noising');\n          } else {\n            el.classList.remove('noising');\n            el.classList.add('noising-char');\n            if (ch.trim().length > 0) el.classList.add('noising-static');\n          }\n          if (ch.trim().length > 0) {\n            el.classList.add('noising-burst');\n            window.setTimeout(() => { try { el.classList.remove('noising-burst'); } catch {} }, 200);\n          }\n        }\n        nodes = Array.from(span.querySelectorAll('.tw-char')) as HTMLElement[];\n        for (let j=nodes.length-1; j>=chars.length; j--){ nodes[j].remove(); }\n      } catch {}\n      try { (window as any).startShinning && (window as any).startShinning(); } catch {}\n      try { (window as any).startNoising && (window as any).startNoising(); } catch {}\n      if (onDone) try { onDone(); } catch {}\n      typingId = null;\n    }\n  };\n\n  typingId = window.setTimeout(tick, Math.max(10, Math.round(perStep))) as unknown as number;\n  return clearAll;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\lib\\uiHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":34,"column":89,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":34,"endColumn":108}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* UI Helpers as ESM module. Exposes initUiHelpers to attach helpers and start observers. */\nexport type ToastType = 'info' | 'success' | 'error' | 'warn';\n\nexport function initUiHelpers(options?: { attachToWindow?: boolean }) {\n  const attach = options?.attachToWindow !== false;\n  const w = window as any;\n  const d = document;\n\n  // prefers-reduced-motion\n  let reduced = false;\n  try { reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches; } catch {}\n\n  // ---------- TOAST ----------\n  let toaster: HTMLElement | null = null;\n  function ensureToaster(){ if (!toaster) toaster = d.getElementById('toaster'); return toaster; }\n  function toast(msg: string, type: ToastType = 'info'){\n    const host = ensureToaster(); if (!host) return;\n    const el = d.createElement('div');\n    el.className = `toast ${type}`;\n    el.setAttribute('role','status'); el.setAttribute('aria-live','polite');\n    el.textContent = msg || '';\n    host.appendChild(el);\n    setTimeout(()=>{ el.classList.add('show'); }, 10);\n    setTimeout(()=>{ el.classList.remove('show'); el.remove(); }, 2400);\n  }\n\n  // ---------- MODAL CONFIRM (a11y) ----------\n  let modal: HTMLElement | null = null; let lastFocus: Element | null = null;\n  function ensureModal(){ if (!modal) modal = d.getElementById('modal-run'); return modal; }\n  function openModal(){\n    const m = ensureModal(); if (!m) return;\n    lastFocus = (d.activeElement as Element) || null;\n    m.removeAttribute('hidden'); m.setAttribute('aria-hidden','false');\n    const btn = m.querySelector('[data-action=\"confirm\"]') as HTMLButtonElement | null; btn && btn.focus();\n  }\n  function closeModal(){ const m = ensureModal(); if (!m) return; m.setAttribute('hidden',''); m.setAttribute('aria-hidden','true'); (lastFocus as any)?.focus?.(); }\n  function confirmRisk(): Promise<boolean> { return new Promise((resolve)=>{\n    const m = ensureModal(); if (!m) return resolve(false);\n    openModal();\n    function onKey(e: KeyboardEvent){ if (e.key==='Escape'){ cleanup(); resolve(false);} }\n    function onClick(e: MouseEvent){ const t = e.target as Element; if (!t) return; const act = t.getAttribute('data-action'); if (act==='confirm'){ cleanup(); resolve(true);} if (act==='cancel'){ cleanup(); resolve(false);} }\n    function cleanup(){ d.removeEventListener('keydown', onKey); m!.removeEventListener('click', onClick); closeModal(); }\n    d.addEventListener('keydown', onKey); m!.addEventListener('click', onClick);\n  }); }\n\n  // ---------- POPOVER ----------\n  function togglePopover(anchorId: string, html?: string){\n    const a = d.getElementById(anchorId); if (!a) return;\n    let pop = a.querySelector('.popover');\n    if (!pop){ pop = d.createElement('div'); (pop as HTMLElement).className = 'popover'; (pop as HTMLElement).innerHTML = html||''; a.appendChild(pop); }\n    else { (pop as HTMLElement).remove(); }\n  }\n\n  // ---------- INLINE GLITCHING TEXT (chars mutate/flicker) ----------\n  const runningSelectors = new Set<string>();\n  function animationsDisabled(){ return !!(d.body && d.body.classList.contains('no-animations')); }\n  function prefersReduced(){ try { return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; } catch{ return false; } }\n  function randomPrintable(){ return String.fromCharCode(33 + Math.floor(Math.random()*94)); }\n  function startGlitching(selector = '.glitching', changeP = 0.05, glitchP = 0.05){\n    const elements = d.querySelectorAll(selector);\n    if (!elements || !elements.length) return;\n    elements.forEach((element)=>{\n      if (!(element instanceof Element)) return;\n      if ((element as any).dataset.glitchingActive === 'true') return;\n      (element as any).dataset.glitchingActive = 'true';\n      const originalText = element.textContent || '';\n      (element as any).dataset.originalText = originalText;\n      let html = '';\n      for (const ch of originalText){\n        const safe = ch === '<' ? '&lt;' : ch === '>' ? '&gt;' : ch === '&' ? '&amp;' : ch;\n        html += '<span class=\"glitching-char\">'+safe+'</span>';\n      }\n      element.innerHTML = html;\n      const chars = element.querySelectorAll('.glitching-char');\n      chars.forEach((charEl: any)=>{\n        try {\n          charEl.style.display = 'inline-block';\n          charEl.style.whiteSpace = 'pre';\n          charEl.style.width = 'auto';\n          charEl.style.minWidth = '0';\n          charEl.style.maxWidth = 'none';\n          const w = (charEl as HTMLElement).offsetWidth;\n          charEl.style.width = w + 'px';\n          charEl.style.minWidth = w + 'px';\n          charEl.style.maxWidth = w + 'px';\n          charEl.style.textAlign = 'center';\n          charEl.style.overflow = 'hidden';\n        } catch {}\n      });\n      const id = window.setInterval(()=>{\n        if (animationsDisabled() || prefersReduced()) return;\n        chars.forEach((charEl: any, idx: number)=>{\n          try {\n            charEl.classList.remove('glitch-1','glitch-2');\n            if (Math.random() < glitchP){ charEl.classList.add(Math.random()>0.5?'glitch-1':'glitch-2'); }\n            if (Math.random() < changeP){\n              const orig = ((element as any).dataset.originalText || '')[idx] || '';\n              const tmp = randomPrintable();\n              charEl.textContent = tmp;\n              setTimeout((el: any, o: string)=>{ try{ el.textContent = o; } catch {} }, 100 + Math.random()*150, charEl, orig);\n            }\n          } catch {}\n        });\n      }, 100);\n      (element as any).dataset.changeInterval = String(id);\n    });\n    try { runningSelectors.add(selector); } catch{}\n  }\n  function stopGlitching(selector = '.glitching'){\n    const elements = d.querySelectorAll(selector);\n    elements.forEach((element)=>{\n      if (!(element instanceof Element)) return;\n      if ((element as any).dataset.glitchingActive !== 'true') return;\n      try { if ((element as any).dataset.changeInterval){ clearInterval(Number((element as any).dataset.changeInterval)); } } catch{}\n      element.innerHTML = (element as any).dataset.originalText || '';\n      delete (element as any).dataset.glitchingActive;\n      delete (element as any).dataset.originalText;\n      delete (element as any).dataset.changeInterval;\n    });\n    try { runningSelectors.delete(selector); } catch{}\n  }\n\n  // ---------- NOISE CANVAS (throttled) ----------\n  function bootNoiseCanvas(){\n    const canvasEl = d.getElementById('noise-canvas') as HTMLCanvasElement | null; if (!canvasEl) return;\n    const ctxEl = canvasEl.getContext('2d'); if (!ctxEl) return;\n    function resize(){ canvasEl!.width = innerWidth; canvasEl!.height = innerHeight; }\n    resize(); window.addEventListener('resize', resize);\n    let running = false; let id: number | null = null; let last = 0;\n    function loop(ts: number){\n      if (!running) return;\n      const now = ts || performance.now();\n      if (now - last < 1000/6) { id = requestAnimationFrame(loop); return; }\n      last = now;\n      const w=canvasEl!.width,h=canvasEl!.height; const img = ctxEl!.createImageData(w,h);\n      for (let i=0;i<img.data.length;i+=4){ const v=(Math.random()*255)|0; img.data[i]=img.data[i+1]=img.data[i+2]=v; img.data[i+3]=20; }\n      ctxEl!.putImageData(img,0,0);\n      id = requestAnimationFrame(loop);\n    }\n    function start(){ if (reduced || d.body.classList.contains('no-animations')) return; if (running) return; running = true; loop(0 as any); }\n    function stop(){ running=false; if (id){ cancelAnimationFrame(id); id=null; } ctxEl!.clearRect(0,0,canvasEl!.width,canvasEl!.height); }\n    w.startNoise = start; w.stopNoise = stop;\n    if (!d.body.classList.contains('no-animations')) start();\n  }\n\n  // ---------- Shinning API: expose stubs if not provided elsewhere ----------\n  if (typeof w.startShinning !== 'function') w.startShinning = function(){ /* no-op bootstrap, provided by page */ return; };\n  if (typeof w.stopShinning !== 'function') w.stopShinning = function(){ /* noop */ return; };\n\n  // attach to window if requested\n  if (attach){\n    w.toast = toast;\n    w.confirmRisk = confirmRisk;\n    w.togglePopover = togglePopover;\n    w.startGlitching = startGlitching;\n    w.stopGlitching = stopGlitching;\n  }\n\n  // auto boot noise canvas\n  bootNoiseCanvas();\n\n  return { toast, confirmRisk, togglePopover, startGlitching, stopGlitching };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\lib\\videoVisuals.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":47,"column":7,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":47,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":51,"column":161,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":51,"endColumn":200},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":75,"column":7,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":75,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":99,"column":219,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":99,"endColumn":275},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":100,"column":121,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":100,"endColumn":180}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* Video background rotation + glitch canvas + retro pixelation, as ESM module. */\nexport function initVideoVisuals(options?: { attachToWindow?: boolean }){\n  const attach = options?.attachToWindow !== false;\n  const w = window as any;\n  const d = document;\n\n  function prefersReduced(){ try { return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; } catch { return false; } }\n  function animationsDisabled(){ const b = d.body; if (b && b.classList.contains('force-shine')) return false; return prefersReduced() || !!(b && (b.classList.contains('no-animations') || b.classList.contains('animations-disabled'))); }\n\n  // ---------- VIDEO ROTATION ----------\n  let videoContainer: HTMLElement | null = null;\n  let activeVideoIndex = -1;\n  let transitionTimeout: number | null = null;\n  let ioVideo: IntersectionObserver | null = null;\n\n  const paths = Array.from({ length: 11 }, (_, i) => {\n    const base = `/video/SYNTHOMA${i + 1}`;\n    return { mp4: `${base}.mp4`, webm: `${base}.webm` };\n  });\n\n  function initializeVideos(){\n    videoContainer = d.querySelector('.video-background') as HTMLElement | null;\n    if (!videoContainer) return;\n    const vids = videoContainer.querySelectorAll('video');\n    for (const [i, vEl] of Array.from(vids).entries()){\n      if (i >= paths.length) break;\n      const v = vEl as HTMLVideoElement;\n      const src = paths[i].mp4;\n      if (v.src !== src) v.src = src;\n      v.loop = true; v.muted = true; v.playsInline = true; v.preload = 'metadata'; v.playbackRate = 0.5;\n      v.addEventListener('error', () => {\n        try {\n          const url = new URL(v.currentSrc || v.src, location.origin);\n          if (url.pathname.endsWith('.mp4')) v.src = v.src.replace('.mp4','.webm');\n          else if (url.pathname.endsWith('.webm')) v.src = v.src.replace('.webm','.mp4');\n        } catch {}\n      }, { once: true });\n    }\n    if (vids.length){\n      vids.forEach(v => v.classList.remove('active'));\n      const max = Math.min(vids.length, paths.length);\n      const startIndex = Math.floor(Math.random() * max);\n      const startVid = vids[startIndex] as HTMLVideoElement | undefined;\n      if (startVid){ startVid.classList.add('active'); activeVideoIndex = startIndex; if (!animationsDisabled()) { try { startVid.play(); } catch {} } }\n    }\n    if ('IntersectionObserver' in window){\n      ioVideo && ioVideo.disconnect();\n      ioVideo = new IntersectionObserver((entries)=>{\n        const vis = entries.some(e => e.isIntersecting);\n        if (!vis){ stopVideoRotation(); const vids2 = videoContainer!.querySelectorAll('video'); vids2.forEach((v:any)=>{ try{ v.pause(); }catch{} }); }\n        else { if (!animationsDisabled()){ startVideoRotation(); const active = videoContainer!.querySelector('video.active') as HTMLVideoElement | null; try { active && active.play && active.play(); } catch {} } }\n      }, { threshold: 0.05 });\n      ioVideo.observe(videoContainer);\n    }\n  }\n  function scheduleNextTransition(){ if (transitionTimeout) window.clearTimeout(transitionTimeout); transitionTimeout = window.setTimeout(transitionToVideo, 15000 + Math.random()*15000); }\n  function transitionToVideo(){ if (!videoContainer) return; const vids = videoContainer.querySelectorAll('video'); if (vids.length < 2) return; let nextIndex = activeVideoIndex; const max = vids.length; if (max > 1){ while (nextIndex === activeVideoIndex){ nextIndex = Math.floor(Math.random()*max); } } const currentVideo = vids[activeVideoIndex] as HTMLVideoElement | undefined; const nextVideo = vids[nextIndex] as HTMLVideoElement | undefined; if (currentVideo) currentVideo.classList.remove('active'); if (nextVideo){ nextVideo.classList.add('active'); if (!animationsDisabled()) { try { nextVideo.play(); } catch {} } } activeVideoIndex = nextIndex; scheduleNextTransition(); }\n  function startVideoRotation(){ scheduleNextTransition(); }\n  function stopVideoRotation(){ if (transitionTimeout){ clearTimeout(transitionTimeout); transitionTimeout = null; } }\n\n  // ---------- GLITCH CANVAS ----------\n  let canvas: HTMLCanvasElement | null = null;\n  let ctx: CanvasRenderingContext2D | null = null;\n  let W = 0, H = 0; let rafId: number | null = null; let last = 0; let running = false; let ioGlitch: IntersectionObserver | null = null;\n  function resize(){ if (!canvas) return; W = window.innerWidth; H = window.innerHeight; canvas.width = W; canvas.height = H; }\n  function draw(ts?: number){ if (!running) return; const now = ts || performance.now(); if (now - last < 1000/5) { rafId = requestAnimationFrame(draw); return; } last = now; if (!ctx) { rafId = requestAnimationFrame(draw); return; } ctx.clearRect(0,0,W,H); ctx.fillStyle = 'rgba(0,0,0,0.10)'; ctx.fillRect(0,0,W,H); const segments = 8 + ((Math.random()*6)|0); const palette = ['rgba(0,255,249,0.18)','rgba(255,0,200,0.14)','rgba(250,255,0,0.10)','rgba(255,255,255,0.06)']; for (let i=0;i<segments;i++){ const fromLeft = Math.random() < 0.5; let y = (Math.random()*H)|0; const h = 2 + ((Math.random()*5)|0); const len = Math.max(30, Math.min(W*0.55, (W * (0.15 + Math.random()*0.4))|0)); const x = fromLeft ? 0 : Math.max(0, W - len); const jitter = ((Math.random()*6)|0) - 3; y = Math.max(0, Math.min(H-1, y + jitter)); ctx.fillStyle = palette[(Math.random()*palette.length)|0]; ctx.fillRect(x, y, len, h); ctx.save(); ctx.globalCompositeOperation = 'lighter'; const overlayLen = Math.max(10, (len * (0.4 + Math.random()*0.4))|0); const overlayX = fromLeft ? x : (x + (len - overlayLen)); ctx.fillRect(overlayX, y, overlayLen, Math.max(1, h-1)); ctx.restore(); } ctx.fillStyle = 'rgba(0,0,0,0.06)'; for (let sy=0; sy<H; sy+=2) ctx.fillRect(0, sy, W, 1); rafId = requestAnimationFrame(draw); }\n  function startGlitch(){ if (!canvas || animationsDisabled()) return; if (running) return; running = true; (canvas as any).style.display='block'; rafId = requestAnimationFrame(draw); }\n  function stopGlitch(){ running = false; if (rafId) cancelAnimationFrame(rafId); rafId=null; if (ctx) ctx.clearRect(0,0,W,H); if(canvas) (canvas as any).style.display='none'; }\n\n  function boot(){\n    initializeVideos();\n    canvas = d.getElementById('glitch-bg') as HTMLCanvasElement | null;\n    if (canvas){ ctx = canvas.getContext('2d'); window.addEventListener('resize', resize); resize(); }\n    if ('IntersectionObserver' in window && canvas){\n      ioGlitch && ioGlitch.disconnect();\n      ioGlitch = new IntersectionObserver((entries)=>{\n        const vis = entries.some(e => e.isIntersecting);\n        if (vis && !animationsDisabled() && !d.hidden) startGlitch(); else stopGlitch();\n      }, { threshold: 0.01 });\n      ioGlitch.observe(canvas);\n    }\n    if (!animationsDisabled()) { startGlitch(); startVideoRotation(); }\n    d.addEventListener('visibilitychange', () => { if (d.hidden) { stopGlitch(); stopVideoRotation(); } else if (!animationsDisabled()) { startGlitch(); startVideoRotation(); } });\n    const mo = new MutationObserver((muts)=>{ for (const mut of muts){ if (mut.attributeName==='class'){ if (animationsDisabled()) { /* stop parallax/reset if added later */ } else { /* start parallax if added later */ } break; } } });\n    try { mo.observe(d.body, { attributes: true }); } catch {}\n  }\n\n  // ---------- RETRO PIXELATION ----------\n  let rCanvas: HTMLCanvasElement | null = null; let rCtx: CanvasRenderingContext2D | null = null; let rRaf: number | null = null; let rRunning = false; let rIo: IntersectionObserver | null = null; let lastW=0,lastH=0; let oCanvas: HTMLCanvasElement | null = null; let oCtx: CanvasRenderingContext2D | null = null;\n  function isRetro(){ try { return (d.body && d.body.getAttribute('data-theme') === 'retro-arcade'); } catch { return false; } }\n  function retroPixelateEnabled(){ try { const rs = getComputedStyle(d.documentElement); const v = rs.getPropertyValue('--retro-canvas-pixelate').trim(); if (!v) return false; const n = parseFloat(v); return !!n && !isNaN(n); } catch { return false; } }\n  function ensureRetroCanvas(){ const container = d.querySelector('.video-background') as HTMLElement | null; if (!container) return null; let c = d.getElementById('retro-video-canvas') as HTMLCanvasElement | null; if (!c){ c = d.createElement('canvas'); c.id = 'retro-video-canvas'; container.appendChild(c); } rCanvas = c; rCtx = rCanvas.getContext('2d'); if (!oCanvas){ try { oCanvas = d.createElement('canvas'); oCtx = oCanvas.getContext('2d'); } catch {} } return rCanvas; }\n  function resizeRetro(){ if (!rCanvas) return; const container = d.querySelector('.video-background') as HTMLElement | null; if (!container) return; const rect = container.getBoundingClientRect(); const w = Math.max(1, rect.width); const h = Math.max(1, rect.height); if (w===lastW && h===lastH) return; lastW=w; lastH=h; rCanvas.width = w; rCanvas.height = h; }\n  function currentScale(){ let s = 5; try { const cs = getComputedStyle(d.documentElement).getPropertyValue('--pixelate-scale').trim(); if (cs) s = parseFloat(cs) || s; } catch {} return Math.max(1, s); }\n  function targetSize(){ let w = 0, h = 0; try { const rs = getComputedStyle(d.documentElement); const tw = parseInt(rs.getPropertyValue('--pixelate-target-width').trim(), 10); const th = parseInt(rs.getPropertyValue('--pixelate-target-height').trim(), 10); if (tw > 0 && th > 0) { w = tw; h = th; } } catch {} return { w, h }; }\n  function drawRetro(){ if (!rCanvas || !rCtx) return; const container = d.querySelector('.video-background') as HTMLElement | null; if (!container) return; const v = container.querySelector('video.active') as HTMLVideoElement | null; if (v && v.videoWidth && v.videoHeight){ resizeRetro(); const ts = targetSize(); let tw:number, th:number; if (ts.w && ts.h){ tw = ts.w; th = ts.h; } else { const scale = currentScale(); tw = Math.max(1, (rCanvas.width/scale)|0); th = Math.max(1, (rCanvas.height/scale)|0); } try { if (!oCanvas || !oCtx) { oCanvas = d.createElement('canvas'); oCtx = oCanvas.getContext('2d'); } if (!oCanvas || !oCtx) return; oCanvas.width = tw; oCanvas.height = th; const vw = v.videoWidth, vh = v.videoHeight; const cw = tw, ch = th; const s = Math.max(cw / vw, ch / vh); const dw = vw * s; const dh = vh * s; const dx = (cw - dw) / 2; const dy = 0; oCtx.imageSmoothingEnabled = false; oCtx.clearRect(0,0,tw,th); oCtx.drawImage(v, 0, 0, vw, vh, dx, dy, dw, dh); rCtx.imageSmoothingEnabled = false; rCtx.clearRect(0,0,rCanvas.width,rCanvas.height); rCtx.drawImage(oCanvas, 0, 0, tw, th, 0, 0, rCanvas.width, rCanvas.height); } catch {} }\n    rRaf = requestAnimationFrame(drawRetro);\n  }\n  function startRetro(){ if (rRunning || animationsDisabled()) return; ensureRetroCanvas(); if (!rCanvas || !rCtx) return; rRunning = true; const container = d.querySelector('.video-background') as HTMLElement | null; container && container.classList.add('retro-canvas-on'); try { if (typeof w.stopGlitchBg === 'function') w.stopGlitchBg(); } catch {} if ('IntersectionObserver' in window && rIo){ try{ rIo.disconnect(); }catch{} } rIo = new IntersectionObserver((entries)=>{ const vis = entries.some(e=>e.isIntersecting); if (vis && rRunning){ if (!rRaf) rRaf = requestAnimationFrame(drawRetro); } else { if (rRaf){ cancelAnimationFrame(rRaf); rRaf=null; } } }, { threshold: 0.01 }); try { rIo.observe(rCanvas); } catch {} if (!rRaf) rRaf = requestAnimationFrame(drawRetro); window.addEventListener('resize', resizeRetro); }\n  function stopRetro(){ rRunning = false; const container = d.querySelector('.video-background') as HTMLElement | null; container && container.classList.remove('retro-canvas-on'); if (rRaf){ cancelAnimationFrame(rRaf); rRaf=null; } if (rIo){ try{ rIo.disconnect(); }catch{} rIo=null; } window.removeEventListener('resize', resizeRetro); if (rCtx && rCanvas) { try { rCtx.clearRect(0,0,rCanvas.width,rCanvas.height); } catch {} } }\n  function updateRetro(){ if (isRetro() && retroPixelateEnabled() && !animationsDisabled()) startRetro(); else stopRetro(); }\n  function bootRetro(){ const mo = new MutationObserver((muts)=>{ for (const mut of muts){ if (mut.attributeName === 'data-theme' || mut.attributeName === 'class'){ updateRetro(); break; } } }); try { mo.observe(d.body, { attributes:true }); } catch {} updateRetro(); }\n\n  // attach to window\n  if (attach){ w.startGlitchBg = startGlitch; w.stopGlitchBg = stopGlitch; w.startVideoRotation = startVideoRotation; w.stopVideoRotation = stopVideoRotation; w.startRetroPixelation = startRetro; w.stopRetroPixelation = stopRetro; }\n\n  // boot\n  boot(); bootRetro();\n\n  return { startGlitch, stopGlitch, startVideoRotation, stopVideoRotation, startRetro: startRetro, stopRetro: stopRetro };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\providers\\ThemeProvider.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":30,"column":5,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":30,"endColumn":74}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\nimport React, { createContext, useContext, useEffect, useMemo, useState } from 'react';\nimport { ThemeProvider, CssBaseline } from '@mui/material';\nimport { makeTheme, SynthomaMode } from '../styles/theme';\nimport { setTheme as setCssTheme, ThemeName } from '../themeSwitch';\n\ninterface ModeCtx {\n  mode: SynthomaMode;\n  setMode: (m: SynthomaMode) => void;\n}\n\nconst ModeContext = createContext<ModeCtx | undefined>(undefined);\n\nexport const ThemeRegistry: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [mode, setMode] = useState<SynthomaMode>('default');\n\n  // Mapování MUI režimů na CSS témata\n  const MODE_TO_THEME: Record<SynthomaMode, ThemeName> = useMemo(() => ({\n    default: 'synthoma',\n    neon: 'neon-hellfire',\n    glitch: 'acid-glitch',\n    sanity_breach: 'cyber-dystopia',\n  }), []);\n\n  // aplikace atributu data-theme na <html> i <body> a persistence\n  useEffect(() => {\n    if (typeof document === 'undefined') return;\n    const themeName = MODE_TO_THEME[mode];\n    document.documentElement.setAttribute('data-theme', themeName);\n    document.body && document.body.setAttribute('data-theme', themeName);\n    // ulož do localStorage a sjednoť přes utilitu\n    setCssTheme(themeName);\n  }, [mode, MODE_TO_THEME]);\n\n  const theme = useMemo(() => makeTheme(mode), [mode]);\n\n  const value = useMemo(() => ({ mode, setMode }), [mode]);\n\n  return (\n    <ModeContext.Provider value={value}>\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        {children}\n      </ThemeProvider>\n    </ModeContext.Provider>\n  );\n};\n\nexport const useThemeMode = () => {\n  const ctx = useContext(ModeContext);\n  if (!ctx) throw new Error('useThemeMode musí být voláno uvnitř ThemeRegistry.');\n  return ctx;\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\stores\\runStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\styles\\theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\SYNTHOMA\\apps\\web\\src\\themeSwitch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]